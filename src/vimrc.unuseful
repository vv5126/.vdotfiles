" Bash like keys for the command line
cnoremap <C-A>		<Home>
cnoremap <C-E>		<End>
cnoremap <C-K>		<C-U>

cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

" 定义快捷键到行首和行尾
nmap lb 0
nmap le $
"Quickly open a buffer for scripbble
map <leader>q :e ~/buffer<cr>
nmap <leader>fd :se fileformat=dos<CR>
nmap <leader>fu :se fileformat=unix<CR>
" ^z快速进入shell
nmap <C-Z> :shell<cr>

" Remove the Windows ^M - when the encodings gets messed up
noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

map <leader>pp :setlocal paste!<cr>
map <leader>q :e ~/buffer<cr>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Remap VIM 0
map 0 ^

"Move a line of text using ALT+[jk] or Comamnd+[jk] on mac
nmap <A-j> mz:m+<cr>`z
nmap <A-k> mz:m-2<cr>`z
vmap <A-j> :m'>+<cr>`<my`>mzgv`yo`z
vmap <A-k> :m'<-2<cr>`>my`<mzgv`yo`z

" Map space to / (search) and c-space to ? (backgwards search)
map <c-space> ?

" Tab configuration
map <leader>nn :n <cr>

" When pressing <leader>cd switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>

" Do :help cope if you are unsure what cope is. It's super useful!
map <leader>cc :botright cope<cr>
map <F3> :cp<cr>
map <F4> :cn<cr>
nmap <F10> :call HLUDSync()<cr>
nmap <leader>sa :cs add cscope.out<cr>
set csprg=/usr/bin/cscope
nmap <leader>gs :GetScripts<cr>
vmap <C-S-P> dO#endif<Esc>PO#if 0<Esc>

" 设置tag和window间快速跳转
let g:easyWindows = 1
if exists('g:easyWindows')
    " 向上
    map <C-J> <C-W>j<C-W>_
    " 向下
    map <C-K> <C-W>k<C-W>_
    " 向右
    map <C-L> <C-W>l<C-W>_
    " 向左
    map <C-H> <C-W>h<C-W>_
endif

" 映射vsp这些开启新的buffer,默认目录为当前目录
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

" shift tab pages
map <S-Left> :tabp<CR>
map <S-Right> :tabn<CR>
map! <C-Z> <Esc>zzi
map! <C-O> <C-Y>,

" quanxuan jia fuzhi
map <C-A> ggVG$"+y

imap <C-k> <C-y>,
imap <C-t> <C-q><TAB>
"打开树状文件目录
map <C-F3> \be
nmap \ \cc
vmap \ \cc
nmap <F9> :marks<CR>
" nmap <F4> :MarksBrowser<CR>
" nmap <F2> ,mm
" nmap <F3> ,mh

"以unix格式显示换行符
nmap xsm :e ++ff=unix
"以dos格式显示换行符
nmap xsm :e ++ff=dos

nmap <C-x> :b
nmap <C-r> :ConqueTermVSplit bash <cr>
nmap <C-P> :ConqueTermSplit bash <cr>
nmap ff :1,$s///g
nmap ll :n <space>
nmap <F2> :set ic<cr>/

" OmniCppComplete.vim
" c-j自动补全，当补全菜单打开时，c-j,k上下选择
imap <expr> <c-j>      pumvisible()?"\<C-N>":"\<C-X><C-O>"
imap <expr> <c-k>      pumvisible()?"\<C-P>":"\<esc>"
" f:文件名补全，l:行补全，d:字典补全，]:tag补全
imap <C-]>             <C-X><C-]>
imap <C-F>             <C-X><C-F>
imap <C-D>             <C-X><C-D>
imap <C-L>             <C-X><C-L>

map <leader>cw :cw<cr>
imap <C-u> <esc>d0i
imap <C-k> <esc>d$i  " 与自动补全中的绑定冲突

let g:SuperTabRetainCompletionType=2
let g:SuperTabDefaultCompletionType="<C-X><C-O>"

" 通过使用: commands命令，告诉我们文件的哪一行被改变过
set report=0
autocmd BufEnter * :syntax sync fromstart

autocmd BufRead,BufNew :call UMiniBufExplorer

" Turn backup off, since most stuff is in SVN, git anyway...
"set swapfile
let g:indentLine_char = '┊'

" Enable ShowMarks
let showmarks_enable = 1
set wildmode=list:longest,full " 自动补全时，匹配最长子串，列出文件
" Show which marks
let showmarks_include = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLM"
" Ignore help, quickfix, non-modifiable buffers
let showmarks_ignore_type = "hqm"
" Hilight lower & upper marks
let showmarks_hlline_lower = 1
let showmarks_hlline_upper = 1
let marksCloseWhenSelected = 0
set mousemodel=popup

if exists('g:autochdir')
    autocmd BufEnter * if bufname("") !~ "^\[A-Za-z0-9\]*://" | lcd %:p:h | endif
endif

autocmd WinEnter * if &buftype ==#'quickfix' && winnr('$') == 1 | quit |endif
autocmd WinLeave * lclose

func! CurrentFileDir(cmd)
    return a:cmd . " " . expand("%:p:h") . "/"
endfunc

" Specify the behavior when switching between buffers
try
  set switchbuf=usetab
"  set stal=2           //shang mian xian shi
catch
endtry


""""""""""""""""""""""""""""""
" => Command-T
""""""""""""""""""""""""""""""
let g:CommandTMaxHeight = 15
noremap <leader>j :CommandT<cr>
noremap <leader>y :CommandTFlush<cr>

au BufRead,BufNewFile ~/buffer iab <buffer> xh1 ===========================================

let g:neocomplcache_enable_at_startup = 1
lang en_US

"golang
" Processing... % (ctrl+c to stop)
let g:fencview_autodetect=0
autocmd BufNewFile * normal G
:autocmd BufRead,BufNewFile *.dot map <F5> :w<CR>:!dot -Tjpg -o %<.jpg % && eog %<.jpg  <CR><CR> && exec "redr!"

" 根据给定方向搜索当前光标下的单词，结合下面两个绑定使用
execute "normal ?" . l:pattern . "<cr>"
execute "normal /" . l:pattern . "<cr>"

" 插件窗口的宽度，如TagList,NERD_tree等，自己设置
let s:PlugWinSize = 30

" ShowFunc.vim  <-------- 暂时没有使用
" F2打开ShowFunc TagList窗口，显示C/C++函数原型
" map <F2> <Plug>ShowFunc
" map! <F2> <Plug>ShowFunc

" Man.vim
source $VIMRUNTIME/ftplugin/man.vim

" Smart mappings on the command line
cno $h e ~/
cno $d e ~/Desktop/
cno $j e ./
cno $c e <C-\>eCurrentFileDir("e")<cr>

function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction
""""""""""""""""""""""""""""""
" => Minibuffer plugin
""""""""""""""""""""""""""""""
let g:miniBufExplUseSingleClick = 1
let g:miniBufExplVSplit = 25
let g:miniBufExplSplitBelow=1

nmap <S-C> :stj <C-R>=expand("<cword>")<CR><CR>

"Persistent undo
try
    if MySys() == "windows"
      set undodir=C:\Windows\Temp
    else
      set undodir=~/.vim_runtime/undodir
    endif
catch
endtry

au FileType c setlocal dict+=~/.vim/dict/c.dict
au FileType cpp setlocal dict+=~/.vim/dict/cpp.dict
au Filetype * if &omnifunc == "" | setlocal omnifunc=syntaxcomplete#Complete | endif
au FileType c,cpp map <buffer> <leader><space> :w<cr>:make<cr>
set filetype=unix
" ------------------------------------------------
" 自动补全tab触发
function! InsertTabWrapper()
	let col = col('.') - 1
	if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
	else
        return "\<c-p>"
	endif
endfunction
inoremap <Tab> <c-r>=InsertTabWrapper()<cr>
inoremap <S-Tab> <c-n>

"自动补全
":inoremap ) <c-r>=ClosePair(')')<CR>
":inoremap } <c-r>=ClosePair('}')<CR>
":inoremap ] <c-r>=ClosePair(']')<CR>
":inoremap > <c-r>=ClosePair('>')<CR>
":inoremap ( ()<ESC>i
":inoremap { {}<ESC>i
":inoremap [ []<ESC>i
":inoremap < <><ESC>i
"inoremap $t <><esc>i
":inoremap { {<CR>}<ESC>O
":inoremap " ""<ESC>i
":inoremap ' ''<ESC>i
function! ClosePair(char)
    if getline('.')[col('.') - 1] == a:char
        return "\<Right>"
    else
        return a:char
    endif
endfunction

" ------------------------------------


" 更新ctags和cscope索引
" href: http://www.vimer.cn/2009/10/把vim打造成一个真正的ide2.html
" 稍作修改，提取出DeleteFile函数，修改ctags和cscope执行命令
map <F12> :call Do_CsTag()<cr>
function! Do_CsTag()
    let dir = getcwd()
    "先删除已有的tags和cscope文件，如果存在且无法删除，则报错。
    if has("cscope")
        silent! execute "cs kill -1"
    endif
    if ( DeleteFile(dir, "tags") ) 
        return
    endif
    if ( DeleteFile(dir, "cscope.files") ) 
        return
    endif
    if ( DeleteFile(dir, "cscope.out") ) 
        return
    endif
    if filereadable("filenametags")
        if(g:iswindows==1)
            let fntdeleted=delete(dir."\\"."filenametags")
        else
            let fntdeleted=delete("./"."filenametags")
        endif
        if(fntdeleted!=0)
            echohl WarningMsg | echo "Fail to do filename! I cannot delete the filenametags" | echohl None
            return
        endif
    endif
    if(executable('ctags'))
        "silent! execute "!ctags -R --langmap=c++:+.inl+.x -h +.inl+.x --c++-kinds=+p --c-kinds=+p --fields=+iaS --extra=+q --excmd=number ."
        " silent! execute "!ctags -R --langmap=c++:+.inl+.x -h +.inl+.x --fields=+iaS --extra=+q ."
        silent! execute "!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q ."
    endif
    if(executable('cscope') && has("cscope") )
        if(g:isWin)
            silent! execute "!dir /s/b *.c*,*.inl,*.x*,*.h*,*.py,*.java,*.s* >> cscope.files"
            silent! execute "!dir /s/b *.c,*.cpp,*.h,*.java,*.cs >> cscope.files"
        else
            silent! execute "!find . -name '*.[hHcCsS]*' -o -name '*.inl' -o -name '*.[xX]*' -o -name '*.[jJ][aA][vV][aA]' -o -name '*.py' > cscope.files"
            silent! execute "!find . -iname '*.[ch]' -o -name '*.cpp' > cscope.files"
        endif
        silent! execute "!cscope -b"
        silent! execute "!cscope -Rb"
        execute "normal :"
        if filereadable("cscope.out")
            execute "cs add cscope.out"
        endif
    endif
    " 刷新屏幕
    silent execute "redraw!"
    execute "redr!"
endfunction
 
function! DeleteFile(dir, filename)
    if filereadable(a:filename)
        if (g:isWin)
            let ret = delete(a:dir."\\".a:filename)
        else
            let ret = delete("./".a:filename)
        endif
        if (ret != 0)
            echohl WarningMsg | echo "Failed to delete ".a:filename | echohl None
            return 1
        else
            return 0
        endif
    endif
    return 0
endfunction

" $q is super useful when browsing on the command line
cno $q <C-\>eDeleteTillSlash()<cr>

func! DeleteTillSlash()
    let g:cmd = getcmdline()
    if MySys() == "linux" || MySys() == "mac"
        let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
    else
        let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
    endif
    if g:cmd == g:cmd_edited
        if MySys() == "linux" || MySys() == "mac"
            let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
        else
            let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
        endif
    endif
    return g:cmd_edited
endfunc


"代码格式优化化
map <F6> :call FormartSrc()<CR><CR>

func FormartSrc()
    exec "w"
    if &filetype == 'c'
        exec "!astyle --style=ansi -a --suffix=none %"
    elseif &filetype == 'cpp' || &filetype == 'hpp'
        exec "r !astyle --style=ansi --one-line=keep-statements -a --suffix=none %> /dev/null 2>&1"
    elseif &filetype == 'perl'
        exec "!astyle --style=gnu --suffix=none %"
    elseif &filetype == 'py'||&filetype == 'python'
        exec "r !autopep8 -i --aggressive %"
    elseif &filetype == 'java'
        exec "!astyle --style=java --suffix=none %"
    elseif &filetype == 'jsp'
        exec "!astyle --style=gnu --suffix=none %"
    elseif &filetype == 'xml'
        exec "!astyle --style=gnu --suffix=none %"
    else
        exec "normal gg=G"
        return
    endif
    exec "e! %"
endfunc

" end









""""""""""""""""""""""""""""""
" => Python section
""""""""""""""""""""""""""""""
autocmd BufEnter *.py set cc=81 " 打开py文件81行高亮
autocmd BufNewFile,BufRead *.py,*.pyw set filetype=python
let python_highlight_all = 1
au FileType python syn keyword pythonDecorator True None False self

au BufNewFile,BufRead *.jinja set syntax=htmljinja
au BufNewFile,BufRead *.mako set ft=mako

au FileType python inoremap <buffer> $r return
au FileType python inoremap <buffer> $i import
au FileType python inoremap <buffer> $p print
au FileType python inoremap <buffer> $f #--- PH ----------------------------------------------<esc>FP2xi
au FileType python map <buffer> <leader>1 /class
au FileType python map <buffer> <leader>2 /def
au FileType python map <buffer> <leader>C ?class
au FileType python map <buffer> <leader>D ?def
" Python 文件的一般设置，比如不要 tab 等
autocmd FileType python set tabstop=4 shiftwidth=4 expandtab
autocmd FileType python map <F12> :!python %<CR>

"python补全
let g:pydiction_location = '~/.vim/after/complete-dict'
let g:pydiction_menu_height = 20

autocmd FileType python set omnifunc=pythoncomplete#Complete
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete

"Delete trailing white space, useful for Python ;)
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc
autocmd BufWrite *.py :call DeleteTrailingWS()
""""""""""""""""""""""""""""""
" => JavaScript section
"""""""""""""""""""""""""""""""
au FileType javascript call JavaScriptFold()
au FileType javascript setl fen
au FileType javascript setl nocindent

au FileType javascript imap <c-t> AJS.log();<esc>hi
au FileType javascript imap <c-a> alert();<esc>hi

au FileType javascript inoremap <buffer> $r return
au FileType javascript inoremap <buffer> $f //--- PH ----------------------------------------------<esc>FP2xi

function! JavaScriptFold()
    setl foldmethod=syntax
    setl foldlevelstart=1
    syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend

    function! FoldText()
    return substitute(getline(v:foldstart), '{.*', '{...}', '')
    endfunction
    setl foldtext=FoldText()
endfunction

" ---------------html------------------
"Bundle 'FredKSchott/CoVim'
let g:html_indent_inctags = "html,body,head,tbody"
let g:html_indent_script1 = "inc"
let g:html_indent_style1 = "inc"

"rkdown to HTML
nmap md :!~/.vim/markdown.pl % > %.html <CR><CR>
nmap fi :!firefox %.html & <CR><CR>
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
au FileType html setlocal dict+=~/.vim/dict/javascript.dict
au FileType html setlocal dict+=~/.vim/dict/css.dict
autocmd BufNewFile,BufRead *.html.twig set filetype=html.twig
" ---------------html------------------

"markdown配置
au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}   set filetype=mkd
au BufRead,BufNewFile *.{go}   set filetype=go
au BufRead,BufNewFile *.{js}   set filetype=javascript

au FileType scale setlocal dict+=~/.vim/dict/scale.dict
au FileType javascript setlocal dict+=~/.vim/dict/javascript.dict
au FileType php setlocal dict+=~/.vim/dict/php_funclist.dict
au FileType css setlocal dict+=~/.vim/dict/css.dict
au FileType css set omnifunc=csscomplete#CompleteCSS
au FileType css setlocal omnifunc=csscomplete#CompleteCSS
au FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS

"syntastic相关
" execute pathogen#infect()
let g:syntastic_python_checkers=['pylint']
let g:syntastic_php_checkers=['php', 'phpcs', 'phpmd']
let g:syntastic_html_tidy_ignore_errors=[" proprietary attribute \"ng-"]


" 然并卵
" autocmd BufNewFile,BufRead *.coffee set filetype=coffee
" autocmd FileType haskell setlocal expandtab shiftwidth=2 softtabstop=2
" autocmd FileType haskell setlocal commentstring=--\ %s
" autocmd FileType haskell setlocal nospell
"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）
" nnoremap <leader>1 :set filetype=xhtml<CR>
" nnoremap <leader>2 :set filetype=css<CR>
" nnoremap <leader>3 :set filetype=javascript<CR>
" nnoremap <leader>4 :set filetype=php<CR>

" if !(g:iswindows==1)
"     autocmd BufNewFile,BufRead *.c
"                 \ map <F9> <Esc><Esc>:!gcc -g -Wall -lm -o %< % <CR>
"     autocmd BufNewFile,BufRead *.c
"                 \ map <S-F9> <Esc><Esc>:!gcc -O3 -o %< % <CR>
"
"     autocmd BufNewFile,BufRead *.cc,*.cpp,*.c++,*.cxx,*.CC
"                 \ map <F9> <Esc><Esc>:!g++ -g -Wall -o %< % <CR>
"     autocmd BufNewFile,BufRead *.cc,*.cpp,*.c++,*.cxx,*.CC
"                 \ map <S-F9> <Esc><Esc>:!g++ -O3 -o %< % <CR>
"
"     autocmd BufNewFile,BufRead *.sh
"                 \ map <F9> <Esc><Esc>:!./% <CR>
"
"     autocmd BufNewFile,BufRead *.py
"                 \ map <F9> <Esc><Esc>:!python -u % <CR>
"
"     map <C-F9> <Esc><Esc>:!./%<<CR>
"     map <C-F8> <Esc><Esc>:!gdb ./%<<CR>
"     map <C-F5> :make<CR>
" endif

"C，C++ 按F5编译运行
map <F5> :call CompileRunGcc()<CR>
func! CompileRunGcc()
	exec "w"
	if &filetype == 'c'
		exec "!g++ % -o %<"
		exec "!time ./%<"
	elseif &filetype == 'cpp'
		exec "!g++ % -o %<"
		exec "!time ./%<"
	elseif &filetype == 'java' 
		exec "!javac %" 
		exec "!time java %<"
	elseif &filetype == 'sh'
		:!time bash %
	elseif &filetype == 'python'
		exec "!time python2.7 %"
    elseif &filetype == 'html'
        exec "!firefox % &"
    elseif &filetype == 'go'
"        exec "!go build %<"
        exec "!time go run %"
    elseif &filetype == 'mkd'
        exec "!~/.vim/markdown.pl % > %.html &"
        exec "!firefox %.html &"
	endif
endfunc

" -------------------gui-----------------
" for gvim
set guitablabel=%t
set go=                     " 不要图形按钮
set langmenu=zh_CN.UTF-8    "菜单使用的语言
" Set font according to system
if (g:iswindows==1)
    set gfn=Bitstream\ Vera\ Sans\ Mono:h10
else
    set gfn=Monospace\ 10
    set shell=/bin/bash
endif


" 禁止显示滚动条
set guioptions-=l
set guioptions-=L
set guioptions-=r
set guioptions-=R

"在gvim中高亮当前行
if (g:isGUI)
    hi cursorline guibg=#333333
    hi CursorColumn guibg=#333333
    set guifont=Consolas\ 14
    set guifontwide=Consolas\ 14
endif
" 设置字符集编码，默认使用utf8
" if (g:isWin)
"     let &termencoding=&encoding " 通常win下的encoding为cp936
"     set fileencodings=utf8,cp936,ucs-bom,latin1
" endif
"
"字体的设置
set guifont=Consolas,Bitstream_Vera_Sans_Mono:h9:cANSI "设置gui下的字体
set guifont=Courier_New:h10:cANSI   " 设置字体
set gfw=幼圆:h10:cGB2312

" -------------------gui-----------------
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"

"  仅仅代码实现参考

" Close the current buffer
map <leader>bd :Bclose<cr>

" 删除buffer时不关闭窗口
command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
    let l:currentBufNum = bufnr("%")
    let l:alternateBufNum = bufnr("#")

    if buflisted(l:alternateBufNum)
        buffer #
    else
        bnext
    endif

    if bufnr("%") == l:currentBufNum
        new
    endif

    if buflisted(l:currentBufNum)
        execute("bdelete! ".l:currentBufNum)
    endif
endfunction

"""""新文件标题""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"新建.c,.h,.sh,.java文件，自动插入文件头
autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec ":call AddTitle()"

function AddTitle()
	call append(0,"/*=============================================================================")
	call append(1,"*")
	call append(2,"* Author: GaoWei - wgao@ingenic.com")
	call append(3,"*")
	call append(4,"* QQ : 429178931")
	call append(5,"*")
	call append(6,"* Last modified: ".strftime("%Y-%m-%d %H:%M"))
	call append(7,"*")
	call append(8,"* Filename: ".expand("%:t"))
	call append(9,"*")
	call append(10,"* Description:")
	call append(11,"*")
	call append(12,"=============================================================================*/")
    "新建文件后，自动定位到文件末尾
    autocmd BufNewFile * normal G
	echohl WarningMsg | echo "Successful in adding the copyright." | echohl None
endfunction

"更新最近修改时间和文件名
function UpdateTitle()
	normal m'
	execute '/# *Last modified:/s@:.*$@\=strftime(":\t%Y-%m-%d %H:%M")@'
	normal ''
	normal mk
	execute '/# *Filename:/s@:.*$@\=":\t\t".expand("%:t")@'
	execute "noh"
	normal 'k
	echohl WarningMsg | echo "Successful in updating the copy right." | echohl None
endfunction

"判断前10行代码里面，是否有Last modified这个单词，
"如果没有的话，代表没有添加过作者信息，需要新添加；
"如果有的话，那么只需要更新即可
map <F6> :call TitleDet()<cr>'s
function TitleDet()
	let n=1
	"默认为添加
	while n < 10
		let line = getline(n)
		if line =~ '^\#\s*\S*Last\smodified:\S*.*$'
			call UpdateTitle()
			return
		endif
		let n = n + 1
	endwhile
	call AddTitle()
endfunction

highlight WhitespaceEOL ctermbg=red guibg=red
match WhitespaceEOL /\s\+$/
