#!/bin/bash

function is_ip() {
    echo $1 | grep -oP "^(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.(1\\d{2}|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$" >/dev/null
    [ "$?" -eq 0 ] && return 0 || return -1
}

#check clean var.
function check_var() {
    local quit var

    quit=${2:+1}
    for val in $@; do
        eval var=\$"$val"
        if [ -z $var ]; then
            echo "some vars doesn't unset!!!" >&2
            [ 'x'$quit == 'x' ] && return 2 || exit 2
        fi
    done
    return 0
}

#clean same lines in one file.
function clean_duplicate_lines() {
    [ $# -eq 1 ] && {
        cp $1 .clean_dup && cat .clean_dup | sort | uniq > $1
    }
}

# 字符串任意抽取, 空格为分隔符。
function get_segment_from_line() {
        [ $# -ne 2 ] && return 1;

        local line="$1"
        local range="$2"
        local count=0
        local ret i j
        [[ "$2" =~ "-" ]] && range="$(seq -s ' ' ${2%%-*} ${2##*-})"

        for i in $line; do
            ((count+=1))

            for j in $range; do
                [ $count -eq $j ] && ret="$ret $i"
            done
        done
        echo "${ret# *}"
}

function get_param() {
        # 不支持参数带空格哦
        # 参数必须以'-'开始，且只能是一个字母，好像数字也行

        [ $# -lt 2 ] && return -1;

        local got=0
        local success=0
        local param_num=0
        local keyword=${1:1}
        local p
        local para
        shift

        for p in "$@"; do
                if [ "${p:0:1}" == '-' ]; then
                        while [ -n "${p:1:1}" ]; do
                                if [ "${p:1:1}" == "$keyword" ]; then
                                        got=1
                                        success=1
                                else
                                        got=0
                                fi
                                p=${p:1}
                        done
                else
                        if [ "$got" -eq 1 ]; then
                                para="$para $p"
                                ((param_num+=1))
                        fi
                fi
        done

        [ -n "$para" ] && echo "${para:1}"
        [ $success -eq 0 ] && return -1 || return $param_num
}


function get_script_dir() {
    SOURCE="$0"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
        DIR="$( cd -P "$( dirname "$SOURCE"   )" && pwd   )"
        SOURCE="$(readlink "$SOURCE")"
        [[ $SOURCE != /*   ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    DIR="$( cd -P "$( dirname "$SOURCE"   )" && pwd   )"
    echo DIR = $DIR
}

function mem() {
	echo mem > /sys/power/state
}


function read_key() {
	local key=$1
	local table=$2

	if [ -f "$table" ]; then
		while read line; do
			if [ "$key" = "${line%=*}" ]; then
				echo "${line#*=}"
				break
			fi
		done < "$table"
	fi
}

nicemount() { (echo "DEVICE PATH TYPE FLAGS" && mount | awk '$2=$4="";1') | column -t; }

function ls_file()
{
    local level=$1
    find . -maxdepth $level -type f | sed 's/^\.\///g' >&1
}

function ls_dir()
{
    local level=$1
    find . -maxdepth $level -type d | sed '1d;s/^\.\///g' >&1
}

function debug()
{
    [ "$debug" == '1' ] && $*
}

# 从格式化输出里提取一列
function col()
{
      awk -v col=$1 '{print $col}'
}

function gen_lib_info() {
    local func_name func_desc line lines i j lib_dir files
    lib_dir="$1"
    rm $lib_dir/ReadMe >/dev/null
    files="$(find "$lib_dir" -name "lib.*")"
    for i in $files; do
        if [ -f "$i" ]; then
            lines="$(sed -n "/^func/=;" "$i")"
            echo "--- $i ---" >> $lib_dir/ReadMe
            for j in $lines; do
                line=$((j-1>0?j-1:0))
                func_name="$(sed -n "$j,$j p;" "$i" | awk '{print $2}')"
                func_desc="$(sed -n "$line,$line p;" "$i")"
                [ "${func_desc:0:1}" == '#' ] || func_desc=''
                echo -e "$func_name: $func_desc" >> $lib_dir/ReadMe
            done
            echo '' >> $lib_dir/ReadMe
        fi
    done

    # 排版
    vim -c "1,$(sed -n '$=' "$lib_dir/ReadMe")EasyAlign :" "$lib_dir/ReadMe"
}


############# will export ##############

# case $(ps -q $$ -o comm=) in
#     'zsh')
#         ;;
#     *)
#         export -f get_script_dir
#         export -f mem
#         export -f read_key
#         export -f nicemount
#         export -f ls_file
#         export -f ls_dir
#         ;;
# esac

########### will export end ############

[[ "${0##*/}" =~ "lib.misc" ]] && $@
