" Bash like keys for the command line
"cnoremap <C-A>		<Home>
"cnoremap <C-E>		<End>
"cnoremap <C-K>		<C-U>

"cnoremap <C-P> <Up>
"cnoremap <C-N> <Down>

" ^z快速进入shell
nmap <C-Z> :shell<cr>
 
" Useful on some European keyboards
map 陆 $
imap 陆 $
vmap 陆 $
cmap 陆 $

" Remove the Windows ^M - when the encodings gets messed up
noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

map <leader>pp :setlocal paste!<cr>
map <leader>q :e ~/buffer<cr>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Remap VIM 0
map 0 ^

"Move a line of text using ALT+[jk] or Comamnd+[jk] on mac
nmap <A-j> mz:m+<cr>`z
nmap <A-k> mz:m-2<cr>`z
vmap <A-j> :m'>+<cr>`<my`>mzgv`yo`z
vmap <A-k> :m'<-2<cr>`>my`<mzgv`yo`z

" Map space to / (search) and c-space to ? (backgwards search)
map <c-space> ?
" Smart way to move btw. windows
"map <C-j> <C-W>j
"map <C-k> <C-W>k
"map <C-h> <C-W>h
"map <C-l> <C-W>l

" Close the current buffer
map <leader>bd :Bclose<cr>

" Tab configuration
map <leader>nn :n <cr>

" When pressing <leader>cd switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>

" Do :help cope if you are unsure what cope is. It's super useful!
map <leader>cc :botright cope<cr>
map <leader>n :cn<cr>
map <leader>p :cp<cr>

":inoremap ( ()<ESC>i
":inoremap ) <c-r>=ClosePair(')')<CR>
":inoremap { {}<ESC>i
":inoremap } <c-r>=ClosePair('}')<CR>
":inoremap [ []<ESC>i
":inoremap ] <c-r>=ClosePair(']')<CR>
":inoremap < <><ESC>i
":inoremap > <c-r>=ClosePair('>')<CR>

function ClosePair(char)
if getline('.')[col('.') - 1] == a:char
return "\<Right>"
else
return a:char
endif
endf

"nmap  <F4> :%s/ *$//g<cr>
"nmap  <F5> <Plug>LookupFile<cr>
"nmap  <F6> :vimgrep /<C-R>=expand("<cword>")<cr>/ **/*.c **/*.h<cr><C-o>:cw<cr>
"nmap <F10> :call HLUDSync()<cr>

"nmap <leader>sa :cs add cscope.out<cr>

"nmap <leader>gs :GetScripts<cr>

vmap <C-S-P> dO#endif<Esc>PO#if 0<Esc>

"Shortcuts using <leader>
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>s? z=

"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）
nnoremap <leader>1 :set filetype=xhtml<CR>
nnoremap <leader>2 :set filetype=css<CR>
nnoremap <leader>3 :set filetype=javascript<CR>
nnoremap <leader>4 :set filetype=php<CR>
" 设置tag和window间快速跳转 
let g:easyWindows = 1
if exists('g:easyWindows')
    " 向上
    map <C-J> <C-W>j<C-W>_  
    " 向下
    map <C-K> <C-W>k<C-W>_
    " 向右
    map <C-L> <C-W>l<C-W>_
    " 向左
    map <C-H> <C-W>h<C-W>_
endif

" 处理折叠行的左右移动
noremap j gj
noremap k gk

" ,fc查找冲突的地方
map <leader>fc /\v^[<\|=>]{7}( .*\|$)<CR>

" ,ff 查找光标后的单词位置，列出选择项
nmap <Leader>ff [I:let nr = input("Which one: ")<Bar>exe "normal " . nr ."[\t"<CR>

" 屏幕左移和右移
map zl zL
map zh zH

" 映射vsp这些开启新的buffer,默认目录为当前目录
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%


" 在文件名上按gf时，在新的tab中打开
"map gf :tabnew <cfile><cr>

" 用c-j,k在buffer之间切换
nn <C-J> :bn<cr>
nn <C-K> :bp<cr>
" Use the arrows to something usefull
"map <right> :bn<cr>
"map <left> :bp<cr>
" 快捷输入
" 自动完成括号和引号
inoremap <leader>1 ()<esc>:let leavechar=")"<cr>i
inoremap <leader>2 []<esc>:let leavechar="]"<cr>i
inoremap <leader>3 {}<esc>:let leavechar="}"<cr>i
inoremap <leader>4 {<esc>o}<esc>:let leavechar="}"<cr>O
inoremap <leader>q ''<esc>:let leavechar="'"<cr>i
inoremap <leader>w ""<esc>:let leavechar='"'<cr>i
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"键盘命令
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
:nmap <silent> <F9> <ESC>:Tlist<RETURN>
" shift tab pages
map <S-Left> :tabp<CR>
map <S-Right> :tabn<CR>
map! <C-Z> <Esc>zzi
map! <C-O> <C-Y>,
map <C-A> ggVG$"+y
map <C-w> <C-w>w
imap <C-k> <C-y>,
imap <C-t> <C-q><TAB>
imap <C-j> <ESC>
" 选中状态下 Ctrl+c 复制
"map <C-v> "*pa
imap <C-v> <Esc>"*pa
"去空行  
nnoremap <F2> :g/^\s*$/d<CR> 
"比较文件  
nnoremap <C-F2> :vert diffsplit 
"nnoremap <Leader>fu :CtrlPFunky<Cr>
"nnoremap <C-n> :CtrlPFunky<Cr>
"打开树状文件目录  
map <C-F3> \be  
"rkdown to HTML  
nmap md :!~/.vim/markdown.pl % > %.html <CR><CR>
nmap fi :!firefox %.html & <CR><CR>
nmap \ \cc
vmap \ \cc
"将tab替换为空格
nmap tt :%s/\t/    /g<CR>

nmap <F9> :marks<CR>
nmap mk :ma<Space>
nmap md :delmarks<Space>
nmap <F4> :MarksBrowser<CR>
nmap <F2> ,mm
nmap <F3> ,mh
vmap <C-S-P> dO#endif<Esc>PO#if 0<Esc>

"set notextmode

map <c-w><Esc>:w <CR>
vmap <c-w><Esc>:w <CR>
imap <c-w> <Esc>:w <CR>
map <C-S><Esc>:w <CR>
vmap <C-S><Esc>:w <CR>
imap <C-S> <Esc>:w <CR>

"以unix格式显示换行符
nmap xsm :e ++ff=unix
"以dos格式显示换行符
nmap xsm :e ++ff=dos
map ff :WMToggle<CR>
map <F4> :WMToggle<CR>

nnoremap <F8> :TlistToggle<CR>

nmap ww :w<cr>
nmap tt :Tlist<cr>
"nmap ww <C-w><C-w>
nmap -- 5<C-w>-
nmap ++ 5<C-w>+
nmap >> 5<C-w>>
nmap << 5<C-w><
nmap <C-x> :b
nmap <C-r> :ConqueTermVSplit bash <cr>
nmap <C-P> :ConqueTermSplit bash <cr>
nmap <C-c> :
nmap 11 :set nonu<cr>
nmap 22 :set nu<cr>
nmap cm :!
map ss :vsplit <Space>
"map vv :vsplit<cr>
nmap ff :1,$s///g
nmap fk :1,$s/ *$//g<cr>
"nmap fk :1,$s/^.*\.//g<cr>	"exaple 12.aaa-->aaa
nmap ll :n <space>
nmap cc :color <space>

nmap ds :%s/\s\+$//<cr>

"nmap vv :vsplit
nmap bd :bdelete<cr>
nmap tc :tabclose<cr>
nmap vv :bnext<cr>
nmap zz :bprevious<cr>
"nmap ff :cs find t <C-R>=expand("<cword>")<CR><CR>:cw<CR>

vmap <F7> :s=^\(//\)*=//=g<cr>:noh<cr>
nmap <F7> :s=^\(//\)*=//=g<cr>:noh<cr>
imap <F7> <ESC>:s=^\(//\)*=//=g<cr>:noh<cr>

vmap <F7># :s=^\(#\)*=#=g<cr>:noh<cr>
nmap <F7># :s=^\(#\)*=#=g<cr>:noh<cr>
imap <F7># <ESC>:s=^\(#\)*=#=g<cr>:noh<cr>
"F6 for uncomment

vmap <F6> :s=^\(//\)*==g<cr>:noh<cr>
nmap <F6> :s=^\(//\)*==g<cr>:noh<cr>
imap <F6> <ESC>:s=^\(//\)*==g<cr>:noh<cr>

"inoremap <C-u> <esc>gUiwea
" 定义快捷键到行首和行尾
nmap lb 0
nmap le $
" 设置快捷键将选中文本块复制至系统剪贴板
vnoremap <Leader>y "+y
" 设置快捷键将系统剪贴板内容粘贴至 vim
nmap <Leader>p "+p
" 定义快捷键关闭当前分割窗口
nmap <Leader>q :q<CR>
" 定义快捷键保存所有窗口内容并退出 vim
nmap <Leader>WQ :wa<CR>:q<CR>
" 定义快捷键在结对符之间跳转，助记pair
nmap <Leader>pa %
"nmap <F2> :set ic<cr>/
map <C-U> :set mouse=a<CR>

" OmniCppComplete.vim
" c-j自动补全，当补全菜单打开时，c-j,k上下选择
imap <expr> <c-j>      pumvisible()?"\<C-N>":"\<C-X><C-O>"
imap <expr> <c-k>      pumvisible()?"\<C-P>":"\<esc>"
" f:文件名补全，l:行补全，d:字典补全，]:tag补全
imap <C-]>             <C-X><C-]>
imap <C-F>             <C-X><C-F>
imap <C-D>             <C-X><C-D>
imap <C-L>             <C-X><C-L> 

" NERD_commenter.vim
" Toggle单行注释/“性感”注释/注释到行尾/取消注释
map <leader>cc ,c<space>
map <leader>cs ,cs
map <leader>c$ ,c$
map <leader>cu ,cu
" Quick Fix 设置
map <leader>cw :cw<cr>
map <F3> :cp<cr>
map <F4> :cn<cr>

" Bash(Emacs)风格键盘绑定
imap <C-a> <Esc>^
imap <C-e> <Esc>$
imap <C-a> <HOME>
imap <C-e> <END>
"imap <C-u> <esc>d0i
"imap <C-k> <esc>d$i  " 与自动补全中的绑定冲突


set mouse=a      " 在所有模式下都允许使用鼠标，还可以是n,v,i,c等
set mouse=n
set mouse=i
set mouse=c
set mouse=h
set mouse=v

set csprg=/usr/bin/cscope
set path+=include;\

"let g:SuperTabRetainCompletionType=2
"let g:SuperTabDefaultCompletionType="<C-X><C-O>"

"折叠方式"zf创建折叠
"set fdm=indent
set fdm=manual
set rtp+=$GOROOT/misc/vim
set cul "高亮光标所在行
set cuc
set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}   "状态行显示的内容  

" 去掉输入错误的提示声音
set noeb

" 使回格键（backspace）正常处理indent, eol, start等
set backspace=2
" 通过使用: commands命令，告诉我们文件的哪一行被改变过
set report=0
autocmd BufEnter * :syntax sync fromstart
set nu              " 显示行号
set lz              " 当运行宏时，在命令执行完成之前，不重绘屏幕
set hid             " 可以在没有保存的情况下切换buffer
set lbr             " 在breakat字符处而不是最后一个字符处断行
set ai              " 自动缩进
set si              " 智能缩进
set nofen
set fdl=10
" 不使用beep或flash
set vb t_vb=
set   completeopt=longest,menuone
set   helpheight=10
set   pumheight=10
"set fenc=utf-8
"set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936
"set fileencoding=utf-8
"set encoding=cp936
" Set 7 lines to the curors - when moving vertical..
set so=7
set nolazyredraw "Don't redraw while executing macros
set mat=2 "How many tenths of a second to blink
set tw=500
set mousehide    " 输入文件时隐藏鼠标
set nowritebackup " 不写入备份文件
set shortmess=atI"  " 关闭欢迎页面
set viewoptions=cursor,folds,slash,unix " viminfo 记录的内容
set scrolljump=5  " 光标离开屏幕范围 
set nojoinspaces  " 用J合并两行用一个空格隔开
set pastetoggle=<F12> " 指定F12进入黏贴模式，可以正常复制缩进
set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " 空格等无效字符显示
set listchars=tab:>-,trail:-

"以UNIX的换行符格式保存文件，注意是去掉一个^M
":set ff=unix
"以dos的换行符格式保存文件, 注意是在行尾变为两个^M
"set ff=dos

" Enable ShowMarks
let showmarks_enable = 1
set wildmode=list:longest,full " 自动补全时，匹配最长子串，列出文件
" Show which marks
let showmarks_include = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLM"
" Ignore help, quickfix, non-modifiable buffers
let showmarks_ignore_type = "hqm"
" Hilight lower & upper marks
let showmarks_hlline_lower = 1
let showmarks_hlline_upper = 1

let marksCloseWhenSelected = 0
set sw=4
set ts=4
set et
set fo+=mB
set sm
set selection=inclusive
set mousemodel=popup

if exists('g:autochdir')
    autocmd BufEnter * if bufname("") !~ "^\[A-Za-z0-9\]*://" | lcd %:p:h | endif
endif

" 特殊文件打开
autocmd BufNewFile,BufRead *.py,*.pyw set filetype=python
autocmd BufNewFile,BufRead *.html.twig set filetype=html.twig
autocmd FileType haskell setlocal expandtab shiftwidth=2 softtabstop=2
autocmd BufNewFile,BufRead *.coffee set filetype=coffee
autocmd FileType haskell setlocal commentstring=--\ %s
autocmd FileType haskell setlocal nospell

" 黏贴板
if has('clipboard')
    if has('unnamedplus')
        set clipboard=unnamedplus
    else
        set clipboard=unnamed
    endif
endif

" 设置主题,UI
" solarized 主题
if filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vim"))
	let g:solarized_termtrans=1
	let g:solarized_contrast="normal"
	let g:solarized_visibility="normal"
	color solarized             " Load a colorscheme
endif

autocmd BufEnter *.py set cc=81 " 打开py文件81行高亮  

nmap <leader>nt :NERDTreeFind<CR>

" syntastic 配置
" 设置每次w保存后语法检查
function! ToggleErrors()
    Errors
endfunction
let g:syntastic_check_on_open=1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_wq = 0
let syntastic_loc_list_height = 5
let g:syntastic_html_tidy_ignore_errors=[" proprietary attribute \"ng-"]
autocmd WinEnter * if &buftype ==#'quickfix' && winnr('$') == 1 | quit |endif
autocmd WinLeave * lclose

" Ctrlp 和 Ctrlp-funky(,fu)
if isdirectory(expand("~/.vim/bundle/ctrlp.vim/"))
    let g:ctrlp_working_path_mode = 'ra'
    nnoremap <silent> <D-t> :CtrlP<CR>
    nnoremap <silent> <D-r> :CtrlPMRU<CR>
    let g:ctrlp_custom_ignore = {
                \ 'dir':  '\.git$\|\.hg$\|\.svn$',
                \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$' }

    if executable('ag')
        let s:ctrlp_fallback = 'ag %s --nocolor -l -g ""'
    elseif executable('ack-grep')
        let s:ctrlp_fallback = 'ack-grep %s --nocolor -f'
    elseif executable('ack')
        let s:ctrlp_fallback = 'ack %s --nocolor -f'
        " On Windows use "dir" as fallback command.
    else
        let s:ctrlp_fallback = 'find %s -type f'
    endif
    if exists("g:ctrlp_user_command")
        unlet g:ctrlp_user_command
    endif
    let g:ctrlp_user_command = {
                \ 'types': {
                \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
                \ 2: ['.hg', 'hg --cwd %s locate -I .'],
                \ },
                \ 'fallback': s:ctrlp_fallback
                \ }

    if isdirectory(expand("~/.vim/bundle/ctrlp-funky/"))
        " CtrlP extensions
        let g:ctrlp_extensions = ['funky']
        "funky
        nnoremap <Leader>fu :CtrlPFunky<Cr>
    endif
endif

" unkown---------------------------------

" Smart mappings on the command line
cno $h e ~/
cno $d e ~/Desktop/
cno $j e ./
cno $c e <C-\>eCurrentFileDir("e")<cr>
" $q is super useful when browsing on the command line
cno $q <C-\>eDeleteTillSlash()<cr>
try
    lang en_US
catch
endtry

function! CurDir()
    let curdir = substitute(getcwd(), '/Users/amir/', "~/", "g")
    return curdir
endfunction

func! Cwd()
    let cwd = getcwd()
    return "e " . cwd
endfunc

func! CurrentFileDir(cmd)
    return a:cmd . " " . expand("%:p:h") . "/"
endfunc

function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction
""""""""""""""""""""""""""""""
" => Minibuffer plugin
""""""""""""""""""""""""""""""
"let g:miniBufExplUseSingleClick = 1
"let g:miniBufExplVSplit = 25
"let g:miniBufExplSplitBelow=1


autocmd BufRead,BufNew :call UMiniBufExplorer
map <leader>u :TMiniBufExplorer<cr>:TMiniBufExplorer<cr>
nmap <script> <silent> <S-F7> :BufExplorer<CR>

nmap <S-C> :stj <C-R>=expand("<cword>")<CR><CR>

if !(g:iswindows==1)
    autocmd BufNewFile,BufRead *.c
                \ map <F9> <Esc><Esc>:!gcc -g -Wall -lm -o %< % <CR>
    autocmd BufNewFile,BufRead *.c
                \ map <S-F9> <Esc><Esc>:!gcc -O3 -o %< % <CR>

    autocmd BufNewFile,BufRead *.cc,*.cpp,*.c++,*.cxx,*.CC
                \ map <F9> <Esc><Esc>:!g++ -g -Wall -o %< % <CR>
    autocmd BufNewFile,BufRead *.cc,*.cpp,*.c++,*.cxx,*.CC
                \ map <S-F9> <Esc><Esc>:!g++ -O3 -o %< % <CR>

    autocmd BufNewFile,BufRead *.sh
                \ map <F9> <Esc><Esc>:!./% <CR>

    autocmd BufNewFile,BufRead *.py
                \ map <F9> <Esc><Esc>:!python -u % <CR>

    map <C-F9> <Esc><Esc>:!./%<<CR>
    map <C-F8> <Esc><Esc>:!gdb ./%<<CR>
    map <C-F5> :make<CR>
endif


"然并卵
" Close all the buffers
map <leader>ba :1,300 bd!<cr>
" :inoremap ( ()<ESC>i
" :inoremap { {<CR>}<ESC>O
" :inoremap [ []<ESC>i
" :inoremap " ""<ESC>i
" :inoremap ' ''<ESC>i
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Remap VIM 0
"map 0 ^
"nmap <F2> :set mouse=i<cr>
"nmap <F3> :set mouse=a<cr>
highlight WhitespaceEOL ctermbg=red guibg=red
match WhitespaceEOL /\s\+$/
"Quickly open a buffer for scripbble
"map <leader>q :e ~/buffer<cr>
" nmap <leader>fd :se fileformat=dos<CR>
" nmap <leader>fu :se fileformat=unix<CR>

------------------------------------------------


Bundle 'tpope/vim-fugitive'
Bundle 'rstacruz/sparkup', {'rtp': 'vim/'}
let g:indentLine_char = '┊'
"ndle 'tpope/vim-rails.git'
Bundle 'python-imports.vim'
Bundle 'CaptureClipboard'
Bundle 'ctrlp-modified.vim'
Bundle 'last_edit_marker.vim'
Bundle 'synmark.vim'
Bundle 'SQLComplete.vim'
Bundle 'Vim-Script-Updater'
Bundle 'tacahiroy/ctrlp-funky'

" With a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let g:mapleader = ","

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Colors and Fonts
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"syntax enable "Enable syntax hl

" Set font according to system
" set gfn=Monospace\ 10
" set shell=/bin/bash

"if has("gui_running")
"  set background=dark
"  set nonu
"endif

"set encoding=utf8
"try
"    lang en_US
"catch
"endtry

"set ffs=unix,dos,mac "Default file types

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Files, backups and undo
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Turn backup off, since most stuff is in SVN, git anyway...
"set swapfile

"Persistent undo
try
    if MySys() == "windows"
      set undodir=C:\Windows\Temp
    else
      set undodir=~/.vim_runtime/undodir
    endif
catch
endtry

func! Cwd()
  let cwd = getcwd()
  return "e " . cwd
endfunc

func! CurrentFileDir(cmd)
  return a:cmd . " " . expand("%:p:h") . "/"
endfunc

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Moving around, tabs and buffers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Specify the behavior when switching between buffers
try
  set switchbuf=usetab
"  set stal=2           //shang mian xian shi
catch
endtry

" Format the statusline
"set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c
set statusline=%F%m%r%h%w\[line=%l,%v][%p%%]\%{strftime(\"%d/%m/%y\ -\ %H:%M\")}

function! HasPaste()
    if &paste
        return 'PASTE MODE  '
    else
        return ''
    endif
endfunction

"inoremap $t <><esc>i

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General Abbrevs
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr>

set guitablabel=%t

""""""""""""""""""""""""""""""
" => bufExplorer plugin
""""""""""""""""""""""""""""""
let g:bufExplorerDefaultHelp=0
let g:bufExplorerShowRelativePath=1
map <leader>o :BufExplorer<cr>
let g:bufExplorerSortBy = "name"

map <leader>u :TMiniBufExplorer<cr>

""""""""""""""""""""""""""""""
" => Command-T
""""""""""""""""""""""""""""""
let g:CommandTMaxHeight = 15
noremap <leader>j :CommandT<cr>
noremap <leader>y :CommandTFlush<cr>

au BufRead,BufNewFile ~/buffer iab <buffer> xh1 ===========================================

if &term=="xterm"
set t_Sb=^[[4%dm
set t_Sf=^[[3%dm
endif
let g:neocomplcache_enable_at_startup = 1


"set filetype=unix
"删除行尾的一个^M
nmap dm :%s/\r\+$//e<cr>:set ff=unix<cr>

"syntastic相关
execute pathogen#infect()
let g:syntastic_python_checkers=['pylint']
let g:syntastic_php_checkers=['php', 'phpcs', 'phpmd']
"golang
" Processing... % (ctrl+c to stop)
let g:fencview_autodetect=0
autocmd BufNewFile * normal G
:autocmd BufRead,BufNewFile *.dot map <F5> :w<CR>:!dot -Tjpg -o %<.jpg % && eog %<.jpg  <CR><CR> && exec "redr!"

"当打开vim且没有文件时自动打开NERDTree
autocmd vimenter * if !argc() | NERDTree | endif
" 只剩 NERDTree时自动关闭
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
let g:ctrlp_custom_ignore = '\v\.(exe|so|dll)$'
let g:ctrlp_extensions = ['funky']

" VimGDB.vim
if has("gdb")
	set asm=0
	let g:vimgdb_debug_file=""
	run macros/gdb_mappings.vim
endif

getcwd()

set statusline=[%n]\ %f%m%r%h\ \|\ \ pwd:\ %{CurDir()}\ \ \|%=\|\ %l,%c\ %p%%\ \|\ ascii

matchadd('Underlined', '\%>' . 80 . 'v.\+', -1)
" 快捷打开编辑vimrc文件的键盘绑定
map <silent> <leader>ee :e $HOME/.vimrc<cr>

" 设置字符集编码，默认使用utf8
if (g:isWin)
    let &termencoding=&encoding " 通常win下的encoding为cp936
    set fileencodings=utf8,cp936,ucs-bom,latin1
else
    set encoding=utf8
    set fileencodings=utf8,gb2312,gb18030,ucs-bom,latin1
endif

" 获取当前路径，将$HOME转化为~
function! CurDir()
    let curdir = substitute(getcwd(), $HOME, "~", "g")
    return curdir
endfunction
set statusline=[%n]\ %f%m%r%h\ \|\ \ pwd:\ %{CurDir()}\ \ \|%=\|\ %l,%c\ %p%%\ \|\ ascii=%b,hex=%b%{((&fenc==\"\")?\"\":\"\ \|\ \".&fenc)}\ \|\ %{$USER}\ @\ %{hostname()}\


" 根据给定方向搜索当前光标下的单词，结合下面两个绑定使用
        execute "normal ?" . l:pattern . "<cr>"
        execute "normal /" . l:pattern . "<cr>"

" 恢复上次文件打开位置
set viminfo='10,\"100,:20,%,n~/.viminfo
au BufReadPost * if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif

"""""""""""""""""""""
" Uncomment the following to have Vim jump to the last position when reopening a file
 if has("autocmd")
 au BufReadPost * if line("`\"") > 1 && line("`\"") <= line("$") | exe "normal! g`\"" | endif
 endif
"""""""""""""""""""""
" 缩写
iab idate <c-r>=strftime("%Y-%m-%d")<CR>
iab itime <c-r>=strftime("%H:%M")<CR>

" 插件窗口的宽度，如TagList,NERD_tree等，自己设置
let s:PlugWinSize = 30

" ShowFunc.vim  <-------- 暂时没有使用
" F2打开ShowFunc TagList窗口，显示C/C++函数原型
" map <F2> <Plug>ShowFunc
" map! <F2> <Plug>ShowFunc

" taglist.vim
" <leader>t 打开TagList窗口，窗口在右边
nmap <silent> <leader>t :TlistToggle<cr>
let Tlist_GainFocus_On_ToggleOpen = 0
let Tlist_WinWidth = s:PlugWinSize
"let Tlist_Close_On_Select = 1

" NERD tree
let NERDTreeShowHidden = 1
let NERDTreeWinPos = "right"
let NERDTreeWinSize = s:PlugWinSize 
nmap <leader>n :NERDTreeToggle<cr>

" Man.vim
source $VIMRUNTIME/ftplugin/man.vim

