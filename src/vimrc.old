"共享剪贴板
set clipboard+=unnamed
map <F12> gg=G
" 在行和段开始处使用制表符
set smarttab
" 显示中文帮助
if version >= 603
    set helplang=cn
    set encoding=utf-8
endif

set   cinoptions=:0
set   completeopt=longest,menuone
set   fileformat=unix
set   helpheight=10
set   pumheight=10
set   wildignore=*.bak,*.o,*.e,*~
set   wildmode=list:longest,full
highlight WhitespaceEOL ctermbg=red guibg=red 

set termencoding=utf-8
set fileencoding=utf-8
"键盘命令
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nmap <leader>w :w!<cr>
nmap <leader>f :find<cr>
" 映射全选+复制 ctrl+a
map <C-A> ggVGY
map! <C-A> <Esc>ggVGY
" 选中状态下 Ctrl+c 复制
vmap <C-c> "+y
" 设置当文件被改动时自动载入
set autoread
" quickfix模式
autocmd FileType c,cpp map <buffer> <leader><space> :w<cr>:make<cr>
"自动保存
set autowrite
"set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\
" 设置在状态行显示的信息
" 在处理未保存或只读文件的时候，弹出确认
set confirm
"行内替换
set gdefault
" 我的状态行显示的内容（包括文件类型和解码）
"set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}
"set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]
" 命令行（在状态行下）的高度，默认为1，这里是2
set cmdheight=2
" 侦测文件类型
filetype on
" 载入文件类型插件
filetype plugin on
" 为特定文件类型载入相关缩进文件
filetype indent on
filetype plugin indent on   " 开启插件
" 字符间插入的像素行数目
set linespace=0
" 增强模式中的命令行自动完成操作
set wildmenu
" 使回格键（backspace）正常处理indent, eol, start等
set backspace=2
" 允许backspace和光标键跨越行边界
set whichwrap+=<,>,h,l
" Set backspace config
set backspace=indent,eol,start whichwrap+=<,>,[,] "允许退格键的使用
"set whichwrap+=<,>,h,l
au BufRead,BufNewFile *  setfiletype txt

set guioptions-=r
set guioptions-=l
set guioptions-=T           " 隐藏工具栏
set guioptions-=m           " 隐藏菜单栏
set smartindent             " 开启新行时使用智能自动缩进
                            " 不设定在插入状态无法用退格键和 Delete 键删除回车符
set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\ 
                            " 设置在状态行显示的信息
set go=                     " 不要图形按钮
set fdm=indent " ...
set guifont=Courier_New:h10:cANSI   " 设置字体
autocmd InsertLeave * se nocul  " 用浅色高亮当前行
autocmd InsertEnter * se cul    " 用浅色高亮当前行
set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}   "状态行显示的内容
set lazyredraw
"长行显示，解决@@@@的问题
set display=lastline
"比较文件
nnoremap <C-F2> :vert diffsplit
"语言设置
set langmenu=zh_CN.UTF-8
set helplang=cn
"自动补全
:inoremap { {<CR>}<ESC>O
:inoremap } <c-r>=ClosePair('}')<CR>
:inoremap [ []<ESC>i
:inoremap ] <c-r>=ClosePair(']')<CR>
:inoremap " ""<ESC>i
:inoremap ' ''<ESC>i
function! ClosePair(char)
    if getline('.')[col('.') - 1] == a:char
        return "\<Right>"
    else
        return a:char
    endif
endfunction
"打开文件类型检测, 加了这句才可以用智能补全

"[count],cc:光标以下count行逐行添加注释(7,cc)
"[count],cu:光标以下count行逐行取消注释(7,cu)
"[count],cm:光标以下count行尝试添加块注释(7,cm) 

if has("autocmd")
    filetype plugin indent on "根据文件进行缩进
    augroup vimrcEx
        au!
        autocmd FileType text setlocal textwidth=78
        autocmd BufReadPost *
                    \ if line("'\"") > 1 && line("'\"") <= line("$") | "实现打开同一文件时，vim能够自动记住上一次的位置
                    \ exe "normal! g`\"" |
                    \ endif
    augroup END
else
    set autoindent " always set autoindenting on "智能缩进，相应的有cindent，官方说autoindent可以支持各种文件的缩进，但是效果会比只支持C/C++cindent效果会差一点，但笔者并没有看出来
endif " has("autocmd")

map <F12> :call Do_CsTag()<CR>

" With a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader        = ","
let g:mapleader      = ","
let maplocalleader   = ","
let g:maplocalleader = ","

" Set 7 lines to the curors - when moving vertical..
"set so=7

set hid "Change buffer - without saving
set mat=2 "How many tenths of a second to blink
set nu

" Set font according to system
if (g:iswindows==1)
    set gfn=Bitstream\ Vera\ Sans\ Mono:h10
else
    set gfn=Monospace\ 10
    set shell=/bin/bash
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Text, tab and indent related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"指定文件类型,这样.mak和Makefile文件将都会使用真实tab
autocmd FileType Makefile set noexpandtab

set lbr
set tw=500

set ai "Auto indent
set si "Smart indet
set wrap "Wrap lines

map <leader>t2 :setlocal shiftwidth=2<cr>
map <leader>t4 :setlocal shiftwidth=4<cr>
map <leader>t8 :setlocal shiftwidth=4<cr>

""""""""""""""""""""""""""""""
" => Visual mode related
""""""""""""""""""""""""""""""
" Really useful!
"  In visual mode when you press * or # to search for the current selection
vnoremap <silent> * :call VisualSearch('f')<CR>
vnoremap <silent> # :call VisualSearch('b')<CR>

" When you press gv you vimgrep after the selected text
vnoremap <silent> gv :call VisualSearch('gv')<CR>
map <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Command mode related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Smart mappings on the command line
cno $h e ~/
cno $d e ~/Desktop/
cno $j e ./
cno $c e <C-\>eCurrentFileDir("e")<cr>

" $q is super useful when browsing on the command line
cno $q <C-\>eDeleteTillSlash()<cr>

" Bash like keys for the command line
cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Moving around, tabs and buffers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <silent> <leader><cr> :noh<cr>
" Close the current buffer
map <leader>bd :Bclose<cr>
" Close all the buffers
map <leader>ba :1,300 bd!<cr>
" Tab configuration
map <leader>tn :tabnew %<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove

" When pressing <leader>cd switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>

command! Bclose call <SID>BufcloseCloseIt()
" Specify the behavior when switching between buffers
try
    set switchbuf=usetab
    set stal=2
catch
endtry
" Format the statusline
"set statusline=\ %F%m%r%h\ %w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ %w\ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c
set statusline=\ %r%{Tlist_Get_Tagname_By_Line()}%h\ %w\ %F%m%r%h\ %w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ %w\ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c

function! CurDir()
    let curdir = substitute(getcwd(), '/Users/amir/', "~/", "g")
    return curdir
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Parenthesis/bracket expanding
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vnoremap $1 <esc>`>a)<esc>`<i(<esc>
vnoremap $2 <esc>`>a]<esc>`<i[<esc>
vnoremap $3 <esc>`>a}<esc>`<i{<esc>
vnoremap $$ <esc>`>a"<esc>`<i"<esc>
vnoremap $q <esc>`>a'<esc>`<i'<esc>
vnoremap $e <esc>`>a"<esc>`<i"<esc>

" Map auto complete of (, ", ', [
"inoremap $1 ()<esc>i
"inoremap $2 []<esc>i
"inoremap $3 {}<esc>i
"inoremap $4 {<esc>o}<esc>O
"inoremap $q ''<esc>i
"inoremap $e ""<esc>i

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General Abbrevs
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Remap VIM 0
"map 0 ^

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Cope
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Do :help cope if you are unsure what cope is. It's super useful!
map <leader>cc :botright cope<cr>
map <C-n> :cnext<cr>
map <C-p> :cprev<cr>
"nmap <C-t> :colder<CR>:cc<CR>
"nmap <C-o> :colder<CR>:cc<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Spell checking
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Pressing ,ss will toggle and untoggle spell checking
map <leader>ss :setlocal spell!<cr>

"Shortcuts using <leader>
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>s? z=

""""""""""""""""""""""""""""""
" => Fuzzy finder
""""""""""""""""""""""""""""""
try
    call fuf#defineLaunchCommand('FufCWD', 'file', 'fnamemodify(getcwd(), ''%:p:h'')')
    map <leader>t :FufCWD **/<CR>
catch
endtry
map <F7> :FufTag<cr>
map <C-F7> :FufTaggedFile<cr>

""""""""""""""""""""""""""""""
" => Vim grep
""""""""""""""""""""""""""""""
let Grep_Skip_Dirs = 'RCS CVS SCCS .svn generated'
set grepprg=/bin/grep\ -nH

" Remove the Windows ^M - when the encodings gets messed up
noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

"Quickly open a buffer for scripbble
"map <leader>q :e ~/buffer<cr>

try
    lang en_US
catch
endtry

set ffs=unix,dos,mac "Default file types
set cscopequickfix=c-,d-,e-,g-,i-,s-,t-

noremap <Leader>ff :%s/$//g<cr>:%s// /g<cr>


" plugin shortcuts
function! RunShell(Msg, Shell)
	echo a:Msg . '...'
	call system(a:Shell)
	echon 'done'
endfunction
"nmap  <F9> :call RunShell("get tags_dir","tag")<cr>:
"nmap <F2> :set mouse=i<cr>
"nmap <F3> :set mouse=a<cr>
"nmap  <F4> :%s/ *$//g<cr>
"nmap  <F4> :MRU<cr>
"nmap  <F6> :vimgrep /<C-R>=expand("<cword>")<cr>/ **/*.c **/*.h<cr><C-o>:cw<cr>
"nmap  <F9> :call RunShell("Generate tags", "ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .")<cr>
"nmap <F10> :call HLUDSync()<cr>
"nmap <F11> :call RunShell("Generate filename tags", "~/.vim/shell/genfiletags.sh")<cr>
"nmap <F12> :call RunShell("Generate cscope", "cscope -Rb")<cr>:cs add cscope.out<cr>
"nmap <leader>sa :cs add cscope.out<cr>
"nmap <leader>zz <C-w>o
"nmap <leader>gs :GetScripts<cr>

vmap <C-S-P> dO#endif<Esc>PO#if 0<Esc>

" Buffers操作快捷方式!
nnoremap <C-RETURN> :bnext<CR>
nnoremap <C-S-RETURN> :bprevious<CR>

" Tab操作快捷方式!
nnoremap <C-TAB> :tabnext<CR>
nnoremap <C-S-TAB> :tabprev<CR>

"关于tab的快捷键
" map tn :tabnext<cr>
" map tp :tabprevious<cr>
" map td :tabnew .<cr>
" map te :tabedit
" map tc :tabclose<cr>

" set fileformats=unix,dos,mac
" nmap <leader>fd :se fileformat=dos<CR>
" nmap <leader>fu :se fileformat=unix<CR>

" use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result
" map <C-x>l <ESC>:cl<CR>
" map <C-x>n <ESC>:cn<CR>
" map <C-x>p <ESC>:cp<CR>
" map <C-x>c <ESC>:cc<CR>

match WhitespaceEOL /\s\+$/
" AUTO COMMANDS: {{{1
" auto expand tab to blanks
"autocmd FileType c,cpp set expandtab
" Restore the last quit position when open file.
autocmd BufReadPost *
			\ if line("'\"") > 0 && line("'\"") <= line("$") |
			\     exe "normal g'\"" |
			\ endif

" SHORTCUT SETTINGS: {{{1
" "cd" to change to open directory.
let OpenDir=system("pwd")
nmap <silent> <leader>cd :exe 'cd ' . OpenDir<cr>:pwd<cr>
call pathogen#infect()
call pathogen#helptags()
nnoremap <leader>v <Plug>TaskList

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 文本格式和排版
set formatoptions=tcrqn " 自动格式化
set autoindent " 继承前一行的缩进方式，特别适用于多行注释
set cindent " 使用C样式的缩进
set fileformats=unix,dos " 自动识别UNIX格式和MS-DOS格式
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 设置字符集(看情况具体选择)
"let &termencoding = &encoding
"set fileencoding  = gb18030
 set fileencoding  = gb2312
"set fileencodings = utf-8,gbk,ucs-bom,cp936
"set fileencodings = utf-8,gb18030,utf-16,big5
 set fileencodings = utf-8,gb2312,gbk,gb18030
"set fileencodings = ucs-bom,utf-8,chinese
 set fileencodings = ucs-bom,utf-8,cp936
"编码设置
"set enc           = utf-8
"set fencs         = utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 配置多语言环境
if has("multi_byte")
    " UTF-8 编码
    set encoding       = utf-8
    set termencoding   = utf-8
    set formatoptions+ = mM
    " 设定默认解码
    set fenc          = utf-8
    set fencs         = usc-bom,utf-8,euc-jp,gb18030,gbk,gb2312,cp936,iso-8859-1
    if v:lang         = ~? '^\(zh\)\|\(ja\)\|\(ko\)'
        set ambiwidth = double
    endif
else
    echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

" 高亮显示普通txt文件（需要txt.vim脚本）
" 搜索和匹配 
"set matchtime=2             " 短暂跳转到匹配括号的时间
set matchtime=5 " 匹配括号高亮的时间（单位是十分之一秒）
set nowrapscan              " 禁止在搜索到文件两端时重新搜索
"set statusline=%F%m%r%h%w\[POS=%l,%v][%p%%]\%{strftime(\”%d/%m/%y\ -\
%H:%M\”)} 
" 我的状态行显示的内容（包括文件类型和解码）

set shortmess=atI " 启动的时候不显示那个援助索马里儿童的提示`
set report=0 " 通过使用: commands命令，告诉我们文件的哪一行被改变过

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 一般设置
set viminfo+=! " 保存全局变量
"set backup
" 语法高亮
set syntax=on
syntax on                   " 自动语法高亮
syntax enable "Enable syntax hl
set magic " 设置正表达式
set magic "Set magic on, for regular expressions
set backspace=indent,eol,start " 这指明在插入模式下在哪里允许 <BS>
删除光标前面的字符。
" 逗号分隔的三个值分别指：行首的空白字符，换行符和插入模式开始处之前的字符。
set showcmd " 在 Vim 窗口右下角，标尺的右边显示未完成的命令
" :inoremap ( ()<ESC>i
" :inoremap { {<CR>}<ESC>O
" :inoremap [ []<ESC>i
" :inoremap " ""<ESC>i
" :inoremap ' ''<ESC>i

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 编译链接
"
nmap<Leader>m :wa<CR>:make<CR>:cw<CR><CR>
"分解说明下，<Leader>m设定快捷键为;m（;由<Leader>指定），:wa<CR>保持所有打开的文档，
" :make<CR>执行make命令，:cw<CR>显示quickfix（如果有编译错误或警告时），
" 最后的<CR>消除make命令执行完成屏幕上“PressENTER or type command to continue”的输入等待提示信息。

" winmanager 
"
let g:winManagerWindowLayout='NERDTree|BufExplorer'
"let g:winManagerWindowLayout = 'FileExplorer|TagList'
"let g:winManagerWindowLayout = 'FileExplorer'
let g:winManagerWidth = 25
let g:defaultExplorer = 0
nmap wm :WMToggle<cr>
nmap <C-W><C-F> :FirstExplorerWindow<cr>
nmap <C-W><C-B> :BottomExplorerWindow<cr>
autocmd BufWinEnter \[Buf\ List\] setl nonumber

" minibufexpl插件的一般设置
let g:miniBufExplMapWindowNavVim    = 1
let g:miniBufExplMapWindowNavArrows = 1
let g:miniBufExplMapCTabSwitchBufs  = 1
let g:miniBufExplModSelTarget       = 1
"let g:miniBufExplorerMoreThanOne   = 1 "自动打开
let g:tagbar_left                   = 1 "Tagbar放到左边

ccglue
Bundle 'tpope/vim-commentary' " Commentary: 快速注释。
man.vim
cecutil.vba.gz
netrw.vba.gz
vimball.vim
showmarks.vim
tlib.vba.gz
bbs.vba.gz
hookcursormoved.vba.gz
taglist_45.zip
getscript.vba.gz
sketch.zip
Viki.vba.gz
pyclewn
echofunc.vim "函数提示
Tagbar支持面向对象+
MiniBufExplorer
" drawit画图
" conquetermvim中打开终端的功能+
" csExplorer提供列出配色列表的功+
" visincr提供生成数列的功能+
" fencview字符编码识别+
" visincr提供生成数列的功能+ :SO % 后visincr.vba.gz会消失变成visincr.vba
" cmdline completion命令行模式的补全+
"项目管理插件
" project
" bufexplorer打开历史文件列表以达到快速切换文件+
" genutils底层的lookupfile的功能支持+
" FuzzyFinder缓冲器/文件/命令/标签/等浏览器的模糊匹配 +
" l9FuzzyFinder底层依耐+
"c/c++ 辅助
" c.vim
" stl.vimstl语法高亮+
" stlrefvimstl帮助 +
" checksyntax.vba语法检查+
(跟lookupfile.vim的F5冲突了，把checksyntax.vimF5改成F6)
auto.vim自动排版，可以少打很多空格
"-----------------------------------------------------------------
" plugin - bufexplorer.vim Buffers切换
" \be 全屏方式查看全部打开的文件列表
" \bv 左右方式查看   \bs 上下方式查看
"-----------------------------------------------------------------
" plugin - DoxygenToolkit.vim  由注释生成文档，并且能够快速生成函数标准注释
"-----------------------------------------------------------------
let g:DoxygenToolkit_authorName="Asins - asinsimple AT gmail DOT com"
let g:DoxygenToolkit_briefTag_funcName="yes"
map <leader>da :DoxAuthor<CR>
map <leader>df :Dox<CR>
map <leader>db :DoxBlock<CR>
map <leader>dc a /*  */<LEFT><LEFT><LEFT>
"-----------------------------------------------------------------
" plugin - matchit.vim   对%命令进行扩展使得能在嵌套标签和语句之间跳转
" % 正向匹配      g% 反向匹配
" [% 定位块首     ]% 定位块尾
"-----------------------------------------------------------------

function! <SID>BufcloseCloseIt()
    let l:currentBufNum = bufnr("%")
    let l:alternateBufNum = bufnr("#")

    if buflisted(l:alternateBufNum)
        buffer #
    else
        bnext
    endif

    if bufnr("%") == l:currentBufNum
        new
    endif

    if buflisted(l:currentBufNum)
        execute("bdelete! ".l:currentBufNum)
    endif
endfunction

func! Cwd()
    let cwd = getcwd()
    return "e " . cwd
endfunc
func! CurrentFileDir(cmd)
    return a:cmd . " " . expand("%:p:h") . "/"
endfunc

function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

" From an idea by Michael Naumann
function! VisualSearch(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

"maybe unused----------------------------

autocmd FileType css set omnifunc=csscomplete#CompleteCSS
" Python 文件的一般设置，比如不要 tab 等
autocmd FileType python set tabstop=4 shiftwidth=4 expandtab
autocmd FileType python map <F12> :!python %<CR>
"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）
nnoremap <leader>1 :set filetype=xhtml<CR>
nnoremap <leader>2 :set filetype=css<CR>
nnoremap <leader>3 :set filetype=javascript<CR>
nnoremap <leader>4 :set filetype=php<CR>

" 用户目录变量$VIMFILES
if MySys() == "windows"
    let $VIMFILES = $VIM.'/vimfiles'
elseif MySys() == "linux"
    let $VIMFILES = $HOME.'/.vim'
endif

" 设定doc文档目录
let helptags=$VIMFILES.'/doc'
"""""新文件标题""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"新建.c,.h,.sh,.java文件，自动插入文件头 
autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec ":call SetTitle()" 
""定义函数SetTitle，自动插入文件头 
func SetTitle()
    "如果文件类型为.sh文件
    if &filetype == 'sh'
        call setline(1,"\#########################################################################") 
        call append(line("."), "\# File Name: ".expand("%")) 
        call append(line(".")+1, "\# Author: ma6174") 
        call append(line(".")+2, "\# mail: ma6174@163.com") 
        call append(line(".")+3, "\# Created Time: ".strftime("%c")) 
        call append(line(".")+4, "\#########################################################################") 
        call append(line(".")+5, "\#!/bin/bash") 
        call append(line(".")+6, "") 
    else
        call setline(1, "/*************************************************************************") 
        call append(line("."), "    > File Name: ".expand("%")) 
        call append(line(".")+1, "    > Author: ma6174") 
        call append(line(".")+2, "    > Mail: ma6174@163.com ") 
        call append(line(".")+3, "    > Created Time: ".strftime("%c")) 
        call append(line(".")+4, " ************************************************************************/") 
        call append(line(".")+5, "")
    endif
    if &filetype == 'c'
        call append(line(".")+6, "#include<stdio.h>")
        call append(line(".")+7, "")
    endif
    "新建文件后，自动定位到文件末尾
    autocmd BufNewFile * normal G
endfunc
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
function! Do_CsTag()
    let dir = getcwd()
    if filereadable("tags")
        if(g:iswindows==1)
            let tagsdeleted=delete(dir."\\"."tags")
        else
            let tagsdeleted=delete("./"."tags")
        endif
        if(tagsdeleted!=0)
            echohl WarningMsg | echo "Fail to do tags! I cannot delete the tags" | echohl None
            return
        endif
    endif
    if has("cscope")
        silent! execute "cs kill -1"
    endif
    if filereadable("cscope.files")
        if(g:iswindows==1)
            let csfilesdeleted=delete(dir."\\"."cscope.files")
        else
            let csfilesdeleted=delete("./"."cscope.files")
        endif
        if(csfilesdeleted!=0)
            echohl WarningMsg | echo "Fail to do cscope! I cannot delete the cscope.files" | echohl None
            return
        endif
    endif
    if filereadable("cscope.out")
        if(g:iswindows==1)
            let csoutdeleted=delete(dir."\\"."cscope.out")
        else
            let csoutdeleted=delete("./"."cscope.out")
        endif
        if(csoutdeleted!=0)
            echohl WarningMsg | echo "Fail to do cscope! I cannot delete the cscope.out" | echohl None
            return
        endif
    endif
    if filereadable("filenametags")
        if(g:iswindows==1)
            let fntdeleted=delete(dir."\\"."filenametags")
        else
            let fntdeleted=delete("./"."filenametags")
        endif
        if(fntdeleted!=0)
            echohl WarningMsg | echo "Fail to do filename! I cannot delete the filenametags" | echohl None
            return
        endif
    endif
    if(executable('ctags'))
        "silent! execute "!ctags -R --langmap=c++:+.inl+.x -h +.inl+.x --c++-kinds=+p --c-kinds=+p --fields=+iaS --extra=+q --excmd=number ."
        silent! execute "!ctags -R --langmap=c++:+.inl+.x -h +.inl+.x --fields=+iaS --extra=+q ."
    endif
    if(executable('cscope') && has("cscope") )
        if(g:iswindows!=1)
            silent! execute "!find . -name '*.[hHcCsS]*' -o -name '*.inl' -o -name '*.[xX]*' -o -name '*.[jJ][aA][vV][aA]' -o -name '*.py' > cscope.files"
        else
            silent! execute "!dir /s/b *.c*,*.inl,*.x*,*.h*,*.py,*.java,*.s* >> cscope.files"
        endif
        silent! execute "!cscope -Rb"
        execute "normal :"
        if filereadable("cscope.out")
            execute "cs add cscope.out"
        endif
    endif
    silent execute "redraw!"
endfunction

function AddTitle()
	call append(0,"/*=============================================================================")
	call append(1,"*")
	call append(2,"* Author: GaoWei - wgao@ingenic.com")
	call append(3,"*")
	call append(4,"* QQ : 429178931")
	call append(5,"*")
	call append(6,"* Last modified: ".strftime("%Y-%m-%d %H:%M"))
	call append(7,"*")
	call append(8,"* Filename: ".expand("%:t"))
	call append(9,"*")
	call append(10,"* Description:")
	call append(11,"*")
	call append(12,"=============================================================================*/")
	echohl WarningMsg | echo "Successful in adding the copyright." | echohl None
endfunction

"更新最近修改时间和文件名
function UpdateTitle()
	normal m'
	execute '/# *Last modified:/s@:.*$@\=strftime(":\t%Y-%m-%d %H:%M")@'
	normal ''
	normal mk
	execute '/# *Filename:/s@:.*$@\=":\t\t".expand("%:t")@'
	execute "noh"
	normal 'k
	echohl WarningMsg | echo "Successful in updating the copy right." | echohl None
endfunction

"判断前10行代码里面，是否有Last modified这个单词，
"如果没有的话，代表没有添加过作者信息，需要新添加；
"如果有的话，那么只需要更新即可
function TitleDet()
	let n=1
	"默认为添加
	while n < 10
		let line = getline(n)
		if line =~ '^\#\s*\S*Last\smodified:\S*.*$'
			call UpdateTitle()
			return
		endif
		let n = n + 1
	endwhile
	call AddTitle()
endfunction
map <F6> :call TitleDet()<cr>'s
" VimGDB.vim
if has("gdb")
	set asm=0
	let g:vimgdb_debug_file=""
	run macros/gdb_mappings.vim
endif


" unkown---------------------------------

map fg : Dox<cr>
let g:DoxygenToolkit_authorName="Anders"
let g:DoxygenToolkit_licenseTag="My own license\<enter>"
let g:DoxygenToolkit_undocTag="DOXIGEN_SKIP_BLOCK"
let g:DoxygenToolkit_briefTag_pre = "@brief\t"
let g:DoxygenToolkit_paramTag_pre = "@param\t"
let g:DoxygenToolkit_returnTag = "@return\t"
let g:DoxygenToolkit_briefTag_funcName = "no"
let g:DoxygenToolkit_maxFunctionProtoLines = 30

""""""""""""""""""""""""""""""
" => Minibuffer plugin
""""""""""""""""""""""""""""""
"let g:miniBufExplModSelTarget = 1
"let g:miniBufExplorerMoreThanOne = 2
"let g:miniBufExplModSelTarget = 0
"let g:miniBufExplUseSingleClick = 1
"let g:miniBufExplMapWindowNavVim = 1
"let g:miniBufExplVSplit = 25
"let g:miniBufExplSplitBelow=1

"let g:bufExplorerSortBy = "name"

autocmd BufRead,BufNew :call UMiniBufExplorer

map <leader>u :TMiniBufExplorer<cr>:TMiniBufExplorer<cr>
let g:miniBufExplMapCTabSwitchBufs = 1
let g:miniBufExplMapWindowNavVim = 1
let g:miniBufExplMapWindowNavArrows = 1

nmap <script> <silent> <S-F7> :BufExplorer<CR>

set splitbelow
nmap <S-C> :stj <C-R>=expand("<cword>")<CR><CR>

func! DeleteTillSlash()
    let g:cmd = getcmdline()
    if MySys() == "linux" || MySys() == "mac"
        let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
    else
        let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
    endif
    if g:cmd == g:cmd_edited
        if MySys() == "linux" || MySys() == "mac"
            let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
        else
            let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
        endif
    endif
    return g:cmd_edited
endfunc

if !(g:iswindows==1)
    autocmd BufNewFile,BufRead *.c
                \ map <F9> <Esc><Esc>:!gcc -g -Wall -lm -o %< % <CR>
    autocmd BufNewFile,BufRead *.c
                \ map <S-F9> <Esc><Esc>:!gcc -O3 -o %< % <CR>

    autocmd BufNewFile,BufRead *.cc,*.cpp,*.c++,*.cxx,*.CC
                \ map <F9> <Esc><Esc>:!g++ -g -Wall -o %< % <CR>
    autocmd BufNewFile,BufRead *.cc,*.cpp,*.c++,*.cxx,*.CC
                \ map <S-F9> <Esc><Esc>:!g++ -O3 -o %< % <CR>

    autocmd BufNewFile,BufRead *.sh
                \ map <F9> <Esc><Esc>:!./% <CR>

    autocmd BufNewFile,BufRead *.py
                \ map <F9> <Esc><Esc>:!python -u % <CR>

    map <C-F9> <Esc><Esc>:!./%<<CR>
    map <C-F8> <Esc><Esc>:!gdb ./%<<CR>
    map <C-F5> :make<CR>
endif
