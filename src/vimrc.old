
" 相关vim脚本文档 http://vimdoc.sourceforge.net
" 相关好文 https://github.com/yangyangwithgnu/use_vim_as_ide



" 导入vim插件管理文件
if filereadable(expand("~/.vimrc.bundles"))
    source ~/.vimrc.bundles
endif

" 基本配置
set mousehide    " 输入文件时隐藏鼠标
set backspace=indent,eol,start   " 退格键分别可删除缩进，上一行结束，insert之前的字
set showmatch     " 设置匹配模式 
set nowritebackup " 不写入备份文件
" set autowrite     " 切换文件自动保存 https://github.com/terryma/vim-multiple-cursors/raw/master/assets/example1.gif?raw=true
set shortmess=atI"  " 关闭欢迎页面
set viewoptions=cursor,folds,slash,unix " viminfo 记录的内容
set virtualedit=onemore             " 光标可以移到当行最后一个字符之后 
set hidden                          " 切换文件不保存，隐藏 
" set spell         " 拼写检查
set wildmode=list:longest,full " 自动补全时，匹配最长子串，列出文件
set whichwrap=b,s,h,l,<,>,[,]  " 行尾可右移到下行，行首左移到上行,b：退格，s：空格，hl：左右，<>：n/v模式下的左右，[]：i/r模式下的左右
set scrolljump=5  " 光标离开屏幕范围 

set nojoinspaces  " 用J合并两行用一个空格隔开
set pastetoggle=<F12> " 指定F12进入黏贴模式，可以正常复制缩进
set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " 空格等无效字符显示

" 开启新的buffer时，自动转到对应文件目录
let g:autochdir = 1
if exists('g:autochdir')
    autocmd BufEnter * if bufname("") !~ "^\[A-Za-z0-9\]*://" | lcd %:p:h | endif
endif

" 设置u的返回步数限制
if has('persistent_undo')
    set undofile               " 开启u回滚文件记录
    set undolevels=1000         " 最大数量的改变回滚
    set undoreload=10000        " 最大数量重载可回滚行数
endif

" 特殊文件打开
autocmd BufNewFile,BufRead *.py,*.pyw set filetype=python
autocmd BufNewFile,BufRead *.html.twig set filetype=html.twig
autocmd FileType haskell setlocal expandtab shiftwidth=2 softtabstop=2
autocmd BufNewFile,BufRead *.coffee set filetype=coffee
autocmd FileType haskell setlocal commentstring=--\ %s
autocmd FileType haskell setlocal nospell

" 设置tag和window间快速跳转 
let g:easyWindows = 1
if exists('g:easyWindows')
    " 向上
    map <C-J> <C-W>j<C-W>_  
    " 向下
    map <C-K> <C-W>k<C-W>_
    " 向右
    map <C-L> <C-W>l<C-W>_
    " 向左
    map <C-H> <C-W>h<C-W>_
endif

" 处理折叠行的左右移动
noremap j gj
noremap k gk

" ,fc查找冲突的地方
map <leader>fc /\v^[<\|=>]{7}( .*\|$)<CR>

" ,ff 查找光标后的单词位置，列出选择项
nmap <Leader>ff [I:let nr = input("Which one: ")<Bar>exe "normal " . nr ."[\t"<CR>

" 屏幕左移和右移
map zl zL
map zh zH

" 映射vsp这些开启新的buffer,默认目录为当前目录
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

" 黏贴板
if has('clipboard')
    if has('unnamedplus')
        set clipboard=unnamedplus
    else
        set clipboard=unnamed
    endif
endif

"字体的设置
set guifont=Consolas,Bitstream_Vera_Sans_Mono:h9:cANSI "设置gui下的字体
set gfw=幼圆:h10:cGB2312

" 设置主题,UI
" solarized 主题
if filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vim"))
	let g:solarized_termcolors=256
	let g:solarized_termtrans=1
	let g:solarized_contrast="normal"
	let g:solarized_visibility="normal"
	color solarized             " Load a colorscheme
endif

autocmd BufEnter *.py set cc=81 " 打开py文件81行高亮  
" 之前的高亮线太难看，重新制定颜色，这里的black和iterm2颜色配置中的black一样
hi CursorLine   cterm=NONE ctermbg=black guibg=black  
hi CursorColumn   cterm=NONE ctermbg=black guibg=black " 
highlight ColorColumn ctermbg=black guibg=black
set number " 设置行号
hi LineNr ctermbg=black

nmap <leader>nt :NERDTreeFind<CR>

" syntastic 配置
" 设置每次w保存后语法检查
function! ToggleErrors()
    Errors
endfunction
let g:syntastic_check_on_open=1
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_wq = 0
let syntastic_loc_list_height = 5
let g:syntastic_html_tidy_ignore_errors=[" proprietary attribute \"ng-"]
autocmd WinEnter * if &buftype ==#'quickfix' && winnr('$') == 1 | quit |endif
autocmd WinLeave * lclose

" 自动补全tab触发
function! InsertTabWrapper()
	let col = col('.') - 1
	if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
	else
        return "\<c-p>"
	endif
endfunction
inoremap <Tab> <c-r>=InsertTabWrapper()<cr>
inoremap <S-Tab> <c-n>

" Ctrlp 和 Ctrlp-funky(,fu)
if isdirectory(expand("~/.vim/bundle/ctrlp.vim/"))
    let g:ctrlp_working_path_mode = 'ra'
    nnoremap <silent> <D-t> :CtrlP<CR>
    nnoremap <silent> <D-r> :CtrlPMRU<CR>
    let g:ctrlp_custom_ignore = {
                \ 'dir':  '\.git$\|\.hg$\|\.svn$',
                \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$' }

    if executable('ag')
        let s:ctrlp_fallback = 'ag %s --nocolor -l -g ""'
    elseif executable('ack-grep')
        let s:ctrlp_fallback = 'ack-grep %s --nocolor -f'
    elseif executable('ack')
        let s:ctrlp_fallback = 'ack %s --nocolor -f'
        " On Windows use "dir" as fallback command.
    else
        let s:ctrlp_fallback = 'find %s -type f'
    endif
    if exists("g:ctrlp_user_command")
        unlet g:ctrlp_user_command
    endif
    let g:ctrlp_user_command = {
                \ 'types': {
                \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
                \ 2: ['.hg', 'hg --cwd %s locate -I .'],
                \ },
                \ 'fallback': s:ctrlp_fallback
                \ }

    if isdirectory(expand("~/.vim/bundle/ctrlp-funky/"))
        " CtrlP extensions
        let g:ctrlp_extensions = ['funky']
        "funky
        nnoremap <Leader>fu :CtrlPFunky<Cr>
    endif
endif

" complete
autocmd Filetype * if &omnifunc == "" | setlocal omnifunc=syntaxcomplete#Complete | endif
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete

"进行版权声明的设置
"添加或更新头
map <F4> :call TitleDet()<cr>'s
autocmd BufNewFile *.py :call AddTitle()
function AddTitle()
    call append(0,"#! /usr/bin/env python")
    call append(1,"# -*- coding: utf-8 -*-")
    call append(2,"# vim:fenc=utf-8")
    call append(3,"#  Copyright © XYM")
    call append(4,"# CreateTime: ".strftime("%Y-%m-%d %H:%M:%S"))
    call append(5,"")
endf

let python_highlight_all = 1

set rtp+=~/.vim/bundle/vundle
call vundle#rc()
Bundle "gmarik/vundle"
" 星级越多越推荐, 5星为必选，4星强烈推荐，3星比较推荐
" 文件模糊匹配查找 推荐：****
Bundle "kien/ctrlp.vim"
" 函数模糊匹配查找(,fu) 推荐：****
Bundle 'tacahiroy/ctrlp-funky'
" 文件索引树 推荐：*****
Bundle "scrooloose/nerdtree"
" 自动注释 推荐：*****
Bundle 'scrooloose/nerdcommenter'
" 语法检查 推荐：****
Bundle "scrooloose/syntastic"
" 光标多行编辑 <C-n> <C-x> <C-p> 推荐：****
Bundle 'terryma/vim-multiple-cursors'
" 配色主题 推荐：****
Bundle "altercation/vim-colors-solarized"
" 缩进引导线 推荐：****
Bundle "nathanaelkane/vim-indent-guides"
" 文本同级文字选取，和文本处理 推荐：****
Bundle 'kana/vim-textobj-indent'
Bundle 'kana/vim-textobj-user'
" 保存vim编辑信息，比如最后的位置 推荐：****
Bundle "vim-scripts/restore_view.vim"

" python 推荐：****
Bundle 'yssource/python.vim'
Bundle 'python_match.vim'
Bundle 'pythoncomplete'
Bundle 'hdima/python-syntax'
Bundle 'hynek/vim-python-pep8-indent'

" js 推荐：****
Bundle 'elzr/vim-json'
Bundle 'groenewege/vim-less'
Bundle 'pangloss/vim-javascript'
Bundle 'briancollins/vim-jst'
Bundle 'kchmck/vim-coffee-script'

" html 推荐：****
Bundle 'amirh/HTML-AutoCloseTag'
Bundle 'hail2u/vim-css3-syntax'
Bundle 'gorodinskiy/vim-coloresque'
Bundle 'tpope/vim-haml'
Bundle 'mattn/emmet-vim'

if filereadable(expand("~/.vimrc.bundles.local"))
source ~/.vimrc.bundles.local
endif

"maybe unused----------------------------

autocmd FileType css set omnifunc=csscomplete#CompleteCSS
" Python 文件的一般设置，比如不要 tab 等
autocmd FileType python set tabstop=4 shiftwidth=4 expandtab
autocmd FileType python map <F12> :!python %<CR>
"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）
nnoremap <leader>1 :set filetype=xhtml<CR>
nnoremap <leader>2 :set filetype=css<CR>
nnoremap <leader>3 :set filetype=javascript<CR>
nnoremap <leader>4 :set filetype=php<CR>
" quickfix模式
autocmd FileType c,cpp map <buffer> <leader><space> :w<cr>:make<cr>

" Map auto complete of (, ", ', [
"inoremap $1 ()<esc>i
"inoremap $2 []<esc>i
"inoremap $3 {}<esc>i
"inoremap $4 {<esc>o}<esc>O
"inoremap $q ''<esc>i
"inoremap $e ""<esc>i

"自动补全
:inoremap { {<CR>}<ESC>O
:inoremap } <c-r>=ClosePair('}')<CR>
:inoremap [ []<ESC>i
:inoremap ] <c-r>=ClosePair(']')<CR>
:inoremap " ""<ESC>i
:inoremap ' ''<ESC>i
function! ClosePair(char)
    if getline('.')[col('.') - 1] == a:char
        return "\<Right>"
    else
        return a:char
    endif
endfunction
"打开文件类型检测, 加了这句才可以用智能补全
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" 不写文章用不到
" => Spell checking
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Pressing ,ss will toggle and untoggle spell checking
map <leader>ss :setlocal spell!<cr>

"Shortcuts using <leader>
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>s? z=

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <F12> :call Do_CsTag()<CR>
function! Do_CsTag()
    let dir = getcwd()
    if filereadable("tags")
        if(g:iswindows==1)
            let tagsdeleted=delete(dir."\\"."tags")
        else
            let tagsdeleted=delete("./"."tags")
        endif
        if(tagsdeleted!=0)
            echohl WarningMsg | echo "Fail to do tags! I cannot delete the tags" | echohl None
            return
        endif
    endif
    if has("cscope")
        silent! execute "cs kill -1"
    endif
    if filereadable("cscope.files")
        if(g:iswindows==1)
            let csfilesdeleted=delete(dir."\\"."cscope.files")
        else
            let csfilesdeleted=delete("./"."cscope.files")
        endif
        if(csfilesdeleted!=0)
            echohl WarningMsg | echo "Fail to do cscope! I cannot delete the cscope.files" | echohl None
            return
        endif
    endif
    if filereadable("cscope.out")
        if(g:iswindows==1)
            let csoutdeleted=delete(dir."\\"."cscope.out")
        else
            let csoutdeleted=delete("./"."cscope.out")
        endif
        if(csoutdeleted!=0)
            echohl WarningMsg | echo "Fail to do cscope! I cannot delete the cscope.out" | echohl None
            return
        endif
    endif
    if filereadable("filenametags")
        if(g:iswindows==1)
            let fntdeleted=delete(dir."\\"."filenametags")
        else
            let fntdeleted=delete("./"."filenametags")
        endif
        if(fntdeleted!=0)
            echohl WarningMsg | echo "Fail to do filename! I cannot delete the filenametags" | echohl None
            return
        endif
    endif
    if(executable('ctags'))
        "silent! execute "!ctags -R --langmap=c++:+.inl+.x -h +.inl+.x --c++-kinds=+p --c-kinds=+p --fields=+iaS --extra=+q --excmd=number ."
        silent! execute "!ctags -R --langmap=c++:+.inl+.x -h +.inl+.x --fields=+iaS --extra=+q ."
    endif
    if(executable('cscope') && has("cscope") )
        if(g:iswindows!=1)
            silent! execute "!find . -name '*.[hHcCsS]*' -o -name '*.inl' -o -name '*.[xX]*' -o -name '*.[jJ][aA][vV][aA]' -o -name '*.py' > cscope.files"
        else
            silent! execute "!dir /s/b *.c*,*.inl,*.x*,*.h*,*.py,*.java,*.s* >> cscope.files"
        endif
        silent! execute "!cscope -Rb"
        execute "normal :"
        if filereadable("cscope.out")
            execute "cs add cscope.out"
        endif
    endif
    silent execute "redraw!"
endfunction

"""""新文件标题""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"新建.c,.h,.sh,.java文件，自动插入文件头
autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec ":call AddTitle()"

function AddTitle()
	call append(0,"/*=============================================================================")
	call append(1,"*")
	call append(2,"* Author: GaoWei - wgao@ingenic.com")
	call append(3,"*")
	call append(4,"* QQ : 429178931")
	call append(5,"*")
	call append(6,"* Last modified: ".strftime("%Y-%m-%d %H:%M"))
	call append(7,"*")
	call append(8,"* Filename: ".expand("%:t"))
	call append(9,"*")
	call append(10,"* Description:")
	call append(11,"*")
	call append(12,"=============================================================================*/")
    "新建文件后，自动定位到文件末尾
    autocmd BufNewFile * normal G
	echohl WarningMsg | echo "Successful in adding the copyright." | echohl None
endfunction

"更新最近修改时间和文件名
function UpdateTitle()
	normal m'
	execute '/# *Last modified:/s@:.*$@\=strftime(":\t%Y-%m-%d %H:%M")@'
	normal ''
	normal mk
	execute '/# *Filename:/s@:.*$@\=":\t\t".expand("%:t")@'
	execute "noh"
	normal 'k
	echohl WarningMsg | echo "Successful in updating the copy right." | echohl None
endfunction

"判断前10行代码里面，是否有Last modified这个单词，
"如果没有的话，代表没有添加过作者信息，需要新添加；
"如果有的话，那么只需要更新即可
function TitleDet()
	let n=1
	"默认为添加
	while n < 10
		let line = getline(n)
		if line =~ '^\#\s*\S*Last\smodified:\S*.*$'
			call UpdateTitle()
			return
		endif
		let n = n + 1
	endwhile
	call AddTitle()
endfunction
map <F6> :call TitleDet()<cr>'s
" VimGDB.vim
if has("gdb")
	set asm=0
	let g:vimgdb_debug_file=""
	run macros/gdb_mappings.vim
endif


" unkown---------------------------------

" Specify the behavior when switching between buffers
try
    set switchbuf=usetab "控制缓冲区切换的行为
catch
endtry
" Smart mappings on the command line
cno $h e ~/
cno $d e ~/Desktop/
cno $j e ./
cno $c e <C-\>eCurrentFileDir("e")<cr>
" $q is super useful when browsing on the command line
cno $q <C-\>eDeleteTillSlash()<cr>
try
    lang en_US
catch
endtry

function! CurDir()
    let curdir = substitute(getcwd(), '/Users/amir/', "~/", "g")
    return curdir
endfunction

func! Cwd()
    let cwd = getcwd()
    return "e " . cwd
endfunc

func! CurrentFileDir(cmd)
    return a:cmd . " " . expand("%:p:h") . "/"
endfunc

function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction
""""""""""""""""""""""""""""""
" => Minibuffer plugin
""""""""""""""""""""""""""""""
"let g:miniBufExplModSelTarget = 1
"let g:miniBufExplorerMoreThanOne = 2
"let g:miniBufExplModSelTarget = 0
"let g:miniBufExplUseSingleClick = 1
"let g:miniBufExplMapWindowNavVim = 1
"let g:miniBufExplVSplit = 25
"let g:miniBufExplSplitBelow=1

"let g:bufExplorerSortBy = "name"

autocmd BufRead,BufNew :call UMiniBufExplorer

map <leader>u :TMiniBufExplorer<cr>:TMiniBufExplorer<cr>
let g:miniBufExplMapCTabSwitchBufs = 1
let g:miniBufExplMapWindowNavVim = 1
let g:miniBufExplMapWindowNavArrows = 1

nmap <script> <silent> <S-F7> :BufExplorer<CR>

set splitbelow
nmap <S-C> :stj <C-R>=expand("<cword>")<CR><CR>

func! DeleteTillSlash()
    let g:cmd = getcmdline()
    if MySys() == "linux" || MySys() == "mac"
        let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
    else
        let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
    endif
    if g:cmd == g:cmd_edited
        if MySys() == "linux" || MySys() == "mac"
            let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
        else
            let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
        endif
    endif
    return g:cmd_edited
endfunc

if !(g:iswindows==1)
    autocmd BufNewFile,BufRead *.c
                \ map <F9> <Esc><Esc>:!gcc -g -Wall -lm -o %< % <CR>
    autocmd BufNewFile,BufRead *.c
                \ map <S-F9> <Esc><Esc>:!gcc -O3 -o %< % <CR>

    autocmd BufNewFile,BufRead *.cc,*.cpp,*.c++,*.cxx,*.CC
                \ map <F9> <Esc><Esc>:!g++ -g -Wall -o %< % <CR>
    autocmd BufNewFile,BufRead *.cc,*.cpp,*.c++,*.cxx,*.CC
                \ map <S-F9> <Esc><Esc>:!g++ -O3 -o %< % <CR>

    autocmd BufNewFile,BufRead *.sh
                \ map <F9> <Esc><Esc>:!./% <CR>

    autocmd BufNewFile,BufRead *.py
                \ map <F9> <Esc><Esc>:!python -u % <CR>

    map <C-F9> <Esc><Esc>:!./%<<CR>
    map <C-F8> <Esc><Esc>:!gdb ./%<<CR>
    map <C-F5> :make<CR>
endif




" 定义快捷键到行首和行尾
nmap lb 0
nmap le $
" 设置快捷键将选中文本块复制至系统剪贴板
vnoremap <Leader>y "+y
" 设置快捷键将系统剪贴板内容粘贴至 vim
nmap <Leader>p "+p
" 定义快捷键关闭当前分割窗口
nmap <Leader>q :q<CR>
" 定义快捷键保存当前窗口内容
nmap <Leader>w :w<CR>
" 定义快捷键保存所有窗口内容并退出 vim
nmap <Leader>WQ :wa<CR>:q<CR>
" 不做任何保存，直接退出 vim
nmap <Leader>Q :qa!<CR>
" 依次遍历子窗口
nnoremap nw <C-W><C-W>
" 跳转至右方的窗口
nnoremap <Leader>lw <C-W>l
" 跳转至方的窗口
nnoremap <Leader>hw <C-W>h
" 跳转至上方的子窗口
nnoremap <Leader>kw <C-W>k
" 跳转至下方的子窗口
nnoremap <Leader>jw <C-W>j
" 定义快捷键在结对符之间跳转，助记pair
nmap <Leader>pa %
" 禁止显示滚动条
set guioptions-=l
set guioptions-=L
set guioptions-=r
set guioptions-=R

"然并卵
" Close all the buffers
map <leader>ba :1,300 bd!<cr>
" :inoremap ( ()<ESC>i
" :inoremap { {<CR>}<ESC>O
" :inoremap [ []<ESC>i
" :inoremap " ""<ESC>i
" :inoremap ' ''<ESC>i
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Remap VIM 0
"map 0 ^
"nmap <F2> :set mouse=i<cr>
"nmap <F3> :set mouse=a<cr>
highlight WhitespaceEOL ctermbg=red guibg=red
match WhitespaceEOL /\s\+$/
"Quickly open a buffer for scripbble
"map <leader>q :e ~/buffer<cr>
" nmap <leader>fd :se fileformat=dos<CR>
" nmap <leader>fu :se fileformat=unix<CR>
" Close the current buffer
map <leader>bd :Bclose<cr>
command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
    let l:currentBufNum = bufnr("%")
    let l:alternateBufNum = bufnr("#")

    if buflisted(l:alternateBufNum)
        buffer #
    else
        bnext
    endif

    if bufnr("%") == l:currentBufNum
        new
    endif

    if buflisted(l:currentBufNum)
        execute("bdelete! ".l:currentBufNum)
    endif
endfunction

------------------------------------------------
" for gvim
set go=                     " 不要图形按钮
set langmenu=zh_CN.UTF-8    "菜单使用的语言
" Set font according to system
if (g:iswindows==1)
    set gfn=Bitstream\ Vera\ Sans\ Mono:h10
else
    set gfn=Monospace\ 10
    set shell=/bin/bash
endif
