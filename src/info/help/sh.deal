echo '$1 = $1 ; $2 = $2'; 屏蔽$1 ,屏蔽$2，直接显示$1 ,$2，同理也屏蔽了*的通配符作用 

一、Shell语法
1.1、变量声明

变量＝值 （注意：等号两侧不能有空格） 
a="hello"
b=9
unset a 撤销变量 a
readonly a=2 声明静态的变量 a=2 ，不能 unset
export 变量名 可把变量提升为全局环境变量，可供其他shell程序使用

变量应用中要注意：
echo '$1 = $1 ; $2 = $2'; 屏蔽$1 ,屏蔽 $2 ，直接显示 $1 ,$2，同理也屏蔽了 * 的通配符作用
${SAT}day ，变量要与字符串连在一起时，应该用 ${} 
a= `ls -al` 反引号，运行里面的命令，并把结果返回给变量a
a=$(ls -al) 等价于反引号
单引号‘’和双引号“”的区别，单引号完全屏蔽 $a 变量，双引号不屏蔽$a,单引号和双引号都屏蔽 * 的通配符作用。


1.2、数组声明和使用
name[0]="Tom"
name[1]="Tomy"
name[2]="John"
或
name=("Tom" "Tomy" "John")

例子：
#!/bin/bash
name=("Tom" "Tomy" "John")
for i in 0 1 2
do
echo $i:${name[$i]} 

1.3、特殊的变量
$0:脚本名字。此变量包含地址，可以使用basename $0获得脚本名称。
$1:第一个参数
$2,$3,$4,$5,...一次类推。
$# 传递到脚本的参数个数
$* 以一个单字符串显示所有向脚本传递的参数，,以("$1 $2...") 
$$ 脚本运行的ID号
$! 后台运行的最后一个进程的ID号
$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。("$1""$2"...) 
$- 显示shell使用的当前选项。
$? 显示最后命令的推出状况。0表示没有错误。

上面的例子中使用了$0 $1 $2 $# $? 等变量，下面是程序的解释： 
判断运行参数个数，如果不等于2，显示使用"用法帮助", 其中 $0 表示就是脚本自己。 
用grep 在$2 文件中查找$1 字符串。 
判断前一个命令运行后的返回值(一般成功都会返回0, 失败都会返回非0)。 
如果没有成功显示没找到相关信息，否则显示找到了。 
其中"表示转义，在"" 里面还需要显示"号，则需要加上转义符"

参数置换的变量
1、变量=${参数:-word}：如果设置了参数，则用参数的值置换变量的值，否则用word置换。即这种变量的值等于某一个参数的值，如果该参数没有设置，则变量就等于word的值。
[ -z "${COLUMNS:-}" ] && COLUMNS=80
2、变量=${参数:=word}：如果设置了参数，则用参数的值置换变量的值，否则把变量设置成word，然后再用word替换参数的值。注意，位置参数不能用于这种方式，因为在Shell程序中不能为位置参数赋值。
3、变量=${参数:？word}：如果设置了参数，则用参数的值置换变量的值，否则就显示word并从Shell中退出，如果省略了word，则显示标准信息。这种变量要求一定等于某一个参数的值。如果该参数没有设置，就显示一个信息，然后退出，因此这种方式常用于出错指示。
4、变量=${参数:+word}：如果设置了参数，则用word置换变量，否则不进行置换。

字符串匹配的操作：
${PARAMETER#WORD} shell 像文件名扩展中那样扩展 WORD，并从 PARAMETER 扩展后的值的开头删除最短的匹配模式（若存在匹配模式的话）。使用 ‘@’ 或 ‘$’ 即可删除列表中每个参数的模式。 
${PARAMETER##WORD} 导致从开头删除最长的匹配模式而不是最短的匹配模式。 
${PARAMETER%WORD} shell 像文件名扩展中那样扩展 WORD，并从 PARAMETER 扩展后的值末尾删除最短的匹配模式（若存在匹配模式的话）。使用 ‘@’ 或 ‘$’ 即可删除列表中每个参数的模式。 
${PARAMETER%%WORD} 导致从末尾删除最长的匹配模式而不是最短的匹配模式。 
${PARAMETER/PATTERN/STRING} shell 像文件名扩展中那样扩展 PATTERN，并替换 PARAMETER 扩展后的值中最长的匹配模式（若存在匹配模式的话）。为了在 PARAMETER 扩展后的值开头匹配模式，可以给 PATTERN 附上前缀 #，如果要在值末尾匹配模式，则附上前缀 %。如果 STRING 为空，则末尾的 / 可能被忽略，匹配将被删除。使用 ‘@’ 或 ‘$’ 即可对列表中的每个参数进行模式替换。 
${PARAMETER//PATTERN/STRING} 对所有的匹配（而不只是第一个匹配）执行替换。 


變數設定方式 str 沒有設定 str 為空字串 str 已設定非為空字串 
var=${str-expr} var=expr var= var=$str 
var=${str:-expr} var=expr var=expr var=$str 
var=${str+expr} var= var=expr var=expr 
var=${str:+expr} var= var= var=expr 
var=${str=expr} str=expr
var=expr str 不變
var= str 不變
var=$str 
var=${str:=expr} str=expr
var=expr str=expr
var=expr str 不變
var=$str 
var=${str?expr} expr 輸出至 stderr var= var=str 
var=${str:?expr} expr 輸出至 stderr expr 輸出至 stderr var=str 

字符串子集提取：
${x:3:5} 
的值就是 “e val”，

1.4、运算和运算符

1.4.1、整数运算符

整数的算术运算符 
+ － * / % 
赋值运算符 
＋＝ －＝ * ＝ / ＝ ％＝ 
位运算符 
<< >> & | ~ ^ 
位运算赋值运算符 
<< ＝ >> ＝ & ＝ | ＝ ~ ＝ ^ ＝ 
逻辑运算符： 
&& || ! > > ＝ < < ＝ !＝ ＝＝ 

expr命令计算一个表达式的值 
格式 :expr arg
例子：
计算（2 ＋3 ）×4 的值 
1 、分步计算，即先计算2 ＋3 ，再对其和乘4
s=`expr 2 + 3`
expr $s * 4
2 、一步完成计算： 
expr `expr 2 + 3 ` * 4 
说明： 
运算符号和参数之间要有空格分开； 
通配符号（* ）, 在作为乘法运算符时要用 、“” 、‘’ 符号修饰 

关键字let计算表达式的值：
#!/bin/bash
x=2006
let "x = $x + 1"
echo $x
x="a string."
echo $x 

又出现了新的关键字：let。关于整数变量计算，有如下几种：" + - * / % "，他们的意思和字面意思相同，在*和/之前必须冠以反斜线，已防被SHELL先行解释。整数运算一般通过 let 和 expr 这两个指令来实现，如对变量 x 加 1 可以写作：let "x = $x + 1" 或者 x=`expr $x + 1` 

1.4.2、逻辑运算符

对应操作 整数 字符串 
相同 -eq = 
不同 -ne != 
大于 -gt > 
小于 -lt < 
大于或等于 -ge 
小于或等于 -le 
为空 -z 
不为空 -n 

文件操作逻辑运算符：
-d file ----当file是一个目录时,返回 True 
-f file ----当file是一个普通文件时,返回 True 
-r file ----当file是一个只读文件时,返回 True 
-s file ----当file文件长度大于0时,返回 True 
-w file ----当file是一个可写文件时,返回 True 
-x "/bin/ls" ----当/bin/ls是一个可执行文件时,返回 True，目录是否可访问
-e file ----当file存在时,返回True 
-o file ----当file文件的所有者是当前用户时,返回True 
-z file ----当file长度为0时,返回True 
-u -----文件的 UID 标志被设置
-G -----文件的组 ID 和当前用户相同
file1 -nt file2 -----文件 file1 比 file2 更新
file1 -ot file2 -----文件 file1 比 file2 更老 


逻辑连接符：
! expr 当expr的值是False时,返回True 
Expr1 -a expr2 当expr1,expr2值同为True时,返回True 
Expr1 -o expr2 当expr1,expr2的值至少有一个为True时,返回True 

命令逻辑连接符：
[ -r "$mailfolder" ]||{ echo "Can not read $mailfolder" ; exit 1; } 
使用{}把两个命令括起来，表示一个函数的用法。 && 与 ||或
[ -f "/etc/shadow" ] && echo "This computer uses shadow passwors"
注意：在“[”和“]”符号的左右都留有空格

例子：
#!/bin/sh
mailfolder=/var/spool/mail/james
[ -r "$mailfolder" ]||{ echo "Can not read $mailfolder" ; exit 1; }
echo "$mailfolder has mail from:"
grep "^From " $mailfolder
其中 “^From“ 表示以 From 开头的

1.5.2、case语句

例子：
#!/bin/bash 
echo "Hit a key, then hit return."
read Keypress 

case "$Keypress" in
[a-z] ) echo "Lowercase letter";;
[A-Z] ) echo "Uppercase letter";;
[0-9] ) echo "Digit";;
* ) echo "Punctuation, whitespace, or other";;
esac 
exit 0

1.5.3、select 语句
尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。 

select var in ... ; do
　break
done

例子：
#!/bin/sh
echo "What is your favourite OS?"
select var in "Linux" "Gnu Hurd" "Free BSD" "Other"; do
　　　　break
done
echo "You have selected $var"

下面是该脚本运行的结果： 
What is your favourite OS?
1) Linux 
2) Gnu Hurd
3) Free BSD
4) Other
#? 1
You have selected Linux

1.6、循环语句
1.6.1、for语句
for var in 数组列表; do
　#command bolock
done

例子1：
#!/bin/bash
for var in A B C ; do
　echo "var is $var"
done

例子2：
#!/bin/sh
#列出 RPM 的数目
# 用法: showrpm rpmfile1 rpmfile2 ...
# EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm
for rpmpackage in $*; do
　if [ -r "$rpmpackage" ];then
　　echo "== $rpmpackage =="
　　rpm -qi -p $rpmpackage
　else
　　echo "ERROR: cannot read file $rpmpackage"
　fi
done

例子3：
for var1 in "$@" 
do 
#statements 
done
例2和例3的 $* 和“$@”是相同的

1.6.2、while 语句
while [ express ]; do
#command
Done

例子1：
count=1 
while [ -n "$*"] 
do 
echo "this is a parameter number $count $1" 
shift 
count='expr $count + 1' 
done

例子2：
while [ -n "$1" ]; do
case $1 in
-h) help;shift 1;; # function help is called 
# 执行 help 函数 ， shift 1 表示，移除第一个变量 $1 ,则第二个变为： $1 
　　-f) opt_f=1;shift 1;; # variable opt_f is set
　　-l) opt_l=$2;shift 2;; # -l takes an argument -> shift by 2
　　--) shift;break;; # end of options
　　-*) echo "error: no such option $1. -h for help";exit 1;;
　　*) break;;
esac
done

就像平常执行命令一样，当有参数-h 时，则执行相应的动作

1.6.3、breake 和continue
关键字"break" 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。

1.6.4、shiftshift将存放在位置变量中的命令行参数,依次向左传递.例如 
位置变量当前值为: 
$1=file1 $2=file2 $3=file3 
执行一次shift命令后,位置变量的值为: 
$1=file2 $2=file3 
还可以在shift命令中指定位置变量转移的次数, 如: 
shift n 
例子: 
while [ "$1"] 
do 
if [ "$1"="-i"] then 
infile=" $2" 
shift 2 
else if [ "$1"="-o"] then 
outfile="$2" 
shift 2 
else 
echo "Program $0 does not recognize option $1" 
fi 
done 
tr a-z A-Z<$infile>$outfile


二、函数
脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子： 

#!/bin/sh
# vim: set sw=4 ts=4 et:
help()
{
　cat < b2h -- convert binary to decimal
USAGE: b2h [-h] binarynum
OPTIONS: -h help text
EXAMPLE: b2h 111010
will return 58
HELP
　exit 0
}


error()
{　　# print an error and exit
　　echo "$1"
　　exit 1
}

lastchar()
{　　# return the last character of a string in $rval
　　if [ -z "$1" ]; then
　　　　# empty string
　　　　rval=""
　　　　return
　　fi
　　# wc puts some space behind the output this is why we need sed:
　　numofchar=`echo -n "$1" wc -c sed ''s/ //g'' `
　　# now cut out the last char
　　rval=`echo -n "$1" cut -b $numofchar`
}

chop()
{　　# remove the last character in string and return it in $rval
　　if [ -z "$1" ]; then
　　　　# empty string
　　　　rval=""
　　　　return
　　fi
　　# wc puts some space behind the output this is why we need sed:
　　numofchar=`echo -n "$1" wc -c sed ''s/ //g'' `
　　if [ "$numofchar" = "1" ]; then
　　　　# only one char in string
　　　　rval=""
　　　　return
　　fi
　　numofcharminus1=`expr $numofchar "-" 1`
　　# now cut all but the last char:
　　rval=`echo -n "$1" cut -b 0-${numofcharminus1}`
}

while [ -n "$1" ]; do
case $1 in
　　-h) help;shift 1;; # function help is called
　　--) shift;break;; # end of options
　　-*) error "error: no such option $1. -h for help";;
　　*) break;;
esac
done

# The main program
sum=0
weight=1
# one arg must be given:
[ -z "$1" ] && help
binnum="$1"
binnumorig="$1"

while [ -n "$binnum" ]; do
　　lastchar "$binnum"
　　if [ "$rval" = "1" ]; then
　　　　sum=`expr "$weight" "+" "$sum"`
　　fi
　　# remove the last position in $binnum
　　chop "$binnum"
　　binnum="$rval"
　　weight=`expr "$weight" "*" 2`
done
echo "binary $binnumorig is decimal $sum"



Shell for&while 循环详细总结
#!/usr/bin/ksh
#数字段形式
for i in {1..10}
do
   echo $i
done
#详细列出（字符且项数不多）
for File in 1 2 3 4 5 
do 
    echo $File 
done
#对存在的文件进行循环
for shname in `ls *.sh`
do 
          name=`echo "$shname" | awk -F. '{print $1}'`           
          echo $name
done
#查找循环（ls数据量太大的时候也可以用这种方法）
for shname in `find . -type f -name "*.sh"`
do 
          name=`echo "$shname" | awk -F/ '{print $2}'`          
          echo $name
done
#((语法循环--有点像C语法，但记得双括号
for((i=1;i<100;i++))
do
    if((i%3==0))
    then
        echo $i
        continue
    fi
done
#seq形式 起始从1开始
for i in `seq 100`
do
    if((i%3==0))
    then
        echo $i
        continue
    fi
done
#while循环注意为方括号[],且注意空格
min=1
max=100
while [ $min -le $max ]
do
    echo $min
    min=`expr $min + 1`
done  
#双括号形式，内部结构有点像C的语法，注意赋值：i=$(($i+1))
i=1
while(($i<100))
do
    if(($i%4==0))
    then
        echo $i
    fi
    i=$(($i+1))
done
#从配置文件读取，并可以控制进程数量
MAX_RUN_NUM=8
cat cfg/res_card_partition.cfg |grep -v '^$'|grep -v "#" | grep -v grep |while read partition 
do        
                nohup sh inv_res_card_process.sh $partition >log/resCard$partition.log 2>&1 &               
                while [ 1 -eq 1 ]
                do
                                psNum=`ps -ef | grep "inv_res_card_process" | grep -v "grep" | wc -l`
                                if [ $psNum -ge $MAX_RUN_NUM ]
                                then
                                              sleep 5
                                else
                                              break
                                 fi                                        
                done                
done

# 三.循环控制语句 
# break 命令不执行当前循环体内break下面的语句从当前循环退出. 
# continue 命令是程序在本循体内忽略下面的语句,从循环头开始执行


If  [ $a = $b ]                 如果string1等于string2
                                字符串允许使用赋值号做等号
if  [ $string1 !=  $string2 ]   如果string1不等于string2       
if  [ -n $string  ]             如果string 非空(非0），返回0(true)  
if  [ -z $string  ]             如果string 为空
if  [ $sting ]                  如果string 非空，返回0 (和-n类似)         条件表达式引用变量要带$

 条件表达式
if [ -f  file ]    如果文件存在
if [ -d ...   ]    如果目录存在
if [ -s file  ]    如果文件存在且非空 
if [ -r file  ]    如果文件存在且可读
if [ -w file  ]    如果文件存在且可写
if [ -x file  ]    如果文件存在且可执行   
if [ int1 -eq int2 ]    如果int1等于int2   
if [ int1 -ne int2 ]    如果不等于    
if [ int1 -ge int2 ]       如果>=
if [ int1 -gt int2 ]       如果>
if [ int1 -le int2 ]       如果<=
if [ int1 -lt int2 ]       如果<


表达式 含义
${#string}
{#string}
1，取得字符串长度
string=abc12342341          //等号二边不要有空格
echo ${#string}             //结果11
expr length $string         //结果11
expr "$string" : ".*"       //结果11 分号二边要有空格,这里的:根match的用法差不多2，字符串所在位置
expr index $string '123'    //结果4 字符串对应的下标是从0开始的这个方法让我想起来了js的indexOf，各种语言对字符串的操作方法大方向都差不多，如果有语言基础的话，学习shell会很快的。
3，从字符串开头到子串的最大长度
expr match $string 'abc.*3' //结果9个人觉得这个函数的用处不大，为什么要从开头开始呢。
4，字符串截取
echo ${string:4}      //2342341  从第4位开始截取后面所有字符串
echo ${string:3:3}    //123      从第3位开始截取后面3位
echo ${string:3:6}    //123423   从第3位开始截取后面6位
echo ${string: -4}    //2341  ：右边有空格   截取后4位
echo ${string:(-4)}   //2341  同上
expr substr $string 3 3   //123  从第3位开始截取后面3位上面的方法让我想起了，php的substr函数，后面截取的规则是一样的。
5，匹配显示内容
//例3中也有match和这里的match不同，上面显示的是匹配字符的长度，而下面的是匹配的内容
expr match $string '\([a-c]*[0-9]*\)'  //abc12342341
expr $string : '\([a-c]*[0-9]\)'       //abc1
expr $string : '.*\([0-9][0-9][0-9]\)' //341 显示括号中匹配的内容这里括号的用法，是不是根其他的括号用法有相似之处呢，
6，截取不匹配的内容
echo ${string#a*3}     //42341  从$string左边开始，去掉最短匹配子串
echo ${string#c*3}     //abc12342341  这样什么也没有匹配到
echo ${string#*c1*3}   //42341  从$string左边开始，去掉最短匹配子串
echo ${string##a*3}    //41     从$string左边开始，去掉最长匹配子串
echo ${string%3*1}     //abc12342  从$string右边开始，去掉最短匹配子串
echo ${string%%3*1}    //abc12     从$string右边开始，去掉最长匹配子串这里要注意，必须从字符串的第一个字符开始，或者从最后一个开始，
7，匹配并且替换
echo ${string/23/bb}   //abc1bb42341  替换一次
echo ${string//23/bb}  //abc1bb4bb41  双斜杠替换所有匹配
echo ${string/#abc/bb} //bb12342341   #以什么开头来匹配，根php中的^有点像
echo ${string/%41/bb}  //abc123423bb  %以什么结尾来匹配，根php中的$有点像


20.提取扩展名
%%2=${%%1##.}

21.提取文件名
%%2="$(basename %%1)"

22.提取文件路径
%%2="$(dirname %%1)"

23.替换扩展名
%%3="$(basename %%1)$%%2"

24.追加路径
%%3="$(dirname %%1)/$%%2"

[[]]是最快的。




注意：所有字符 与逻辑运算符直接用“空格”分开，不能连到一起。

运算符号	代表意义
=	等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
!=	不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
<	小于 应用于：整型比较 在[] 中，不能使用 表示字符串
>	大于 应用于：整型比较 在[] 中，不能使用 表示字符串
-eq	等于 应用于：整型比较
-ne	不等于 应用于：整型比较
-lt	小于 应用于：整型比较
-gt	大于 应用于：整型比较
-le	小于或等于 应用于：整型比较
-ge	大于或等于 应用于：整型比较
-a	双方都成立（and） 逻辑表达式 –a 逻辑表达式
-o	单方成立（or） 逻辑表达式 –o 逻辑表达式
-z	空字符串
-n	非空字符串



env 显示目前系统中主要预设变量内容
set 显示目前系统中全部变量内量， 这里包括用户设定的变量
 
expr 是一个手工命令行计数器，可计算加减乘除，并输出结果
如： expr 10 + 10   输出结果为20    注意乘法要用：\*
 
declare  声明变量的内容
用法： declare 参数 变量名
参数： -i 定义为整数             -f 定义为函数
        -a 定义为数组             -r 定义为只读
       -x 定义为透过环境输出变量
例如： declare –i a 定义a 为整数，在进行整数运算时，可用a来存储结果
 
 
条件测试：
-e 是否存在    -d 是目录       -f 是文件   -L 符号连接        
-s 文件非空    -r 可读         -w 可写        -x 可执行
 
字符串测试：
  test “str1” 参数 “str2”
  [ “str1” 参数 “str2” ]
参数：    = 两个字符串相等   != 两个字符串不相等
        -z 空串            -n 非空串
 
数值测试：
   test num1 参数 num2
    [ num1 参数 num2 ]
参数：   -eq 数值相等       -ne 数值不相等
        -gt 数1大于数2      -lt 数1小于数2
        -ge 数1大于等于数2
        -le 数1小于等于数2
 
多重条件判定：
-a (and)与  当前后两条件都为真则返回true
-o (or)或   当前后两条件有一个为真则返回true
!           返回相反状态
 
linux开机启动五个脚本文件介绍：
/etc/profile:
此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.
并从/etc/profile.d目录的配置文件中搜集shell的设置. 
  
/etc/bashrc:
为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.
  
~/.bash_profile:
每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该
文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.   
  
~/.bashrc:
该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该  
该文件被读取.   
  
~/.bash_logout:
当每次退出系统(退出bash shell)时,执行该文件.   

另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,
而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是"父子"关系.

~/.bash_profile 是交互式、login 方式进入 bash 运行的
~/.bashrc 是交互式 non-login 方式进入 bash 运行的
通常二者设置大致相同，所以通常前者会调用后者。

检查远程端口是否对bash开放：
echo >/dev/tcp/8.8.8.8/53 && echo "open"

产生随机的十六进制数，其中n是字符数：
openssl rand -hex n

SSH debug 模式:
ssh -vvv user@ip_address

使用pem key的进行SSH连接：
ssh user@ip_address -i key.pem

用wget抓取完整的网站目录结构，存放到本地目录中：
wget -r --no-parent --reject "index.html*" http://hostname/ -P /home/user/dirs

一次创建多个目录：
mkdir -p /home/user/{test,test1,test2}

列出包括子进程的进程树：
ps axwef

创建 war 文件:
jar -cvf name.war file

测试硬盘写入速度：
dd if=/dev/zero of=/tmp/output.img bs=8k count=256k conv=fdatasync; rm -rf /tmp/output.img

测试磁盘读速度:
hdparm -Tt /dev/sda

获取文本的md5 hash：
echo -n "text" | md5sum

检查xml格式：
xmllint --noout file.xml

将tar.gz文件解压到指定目录:
tar zxvf package.tar.gz -C new_dir

使用curl获取HTTP头信息：
curl -I http://www.example.com

修改一些文件或目录的时间戳 (格式为：YYMMDDhhmm):
touch -t 0712250000 file

使用wget从ftp下载:
wget -m ftp://username:password@hostname

生成随机密码 (本例中16位字符长):
LANG=c < /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-16};echo;

快速创建一个文件的备份（扩展名是.bkp）:
cp some_file_name{,.bkp}

访问Windows共享目录：
smbclient -U "DOMAIN\user" //dc.domain.com/share/test/dir

运行history中的命令 (这里在history中的第100个):
!100

unzip到目录中:
unzip package_name.zip -d dir_name

输入多行文字 (按 CTRL + d 退出):
cat > test.txt

创建空白的文件或者清空已存在的文件:
> test.txt

从Ubuntu NTP服务器上更新日期:
ntpdate ntp.ubuntu.com

netstat 显示所有IPv4的TCP监听的端口:
netstat -lnt4 | awk '{print $4}' | cut -f2 -d: | grep -o '[0-9]*'

将qcow2的镜像转化成raw格式:
qemu-img convert -f qcow2 -O raw precise-server-cloudimg-amd64-disk1.img \
precise-server-cloudimg-amd64-disk1.raw

重复运行命令并显示它的输出 (默认2秒重复一次):
watch ps -ef

显示所有用户:
getent passwd

以读写模式挂载根文件系统:
mount -o remount,rw /

挂载目录 (适合于符号链接不能工作的情况下):
mount --bind /source /destination

发送DNS动态更新给DNS:
nsupdate <<EOF update add $HOST 86400 A $IP send EOF

递归grep所有目录
grep -r "some_text" /path/to/dir

列出10个最大的系统中已打开的文件:
lsof / | awk '{ if($7 > 1048576) print $7/1048576 "MB "$9 }' | sort -n -u | tail

以MB显示空余内存:
free -m | grep cache | awk '/[0-9]/{ print $4" MB" }'

打开vim并跳转到文件最后:
vim + some_file_name

git clone特定branch (本例是master分支):
git clone git@github.com:name/app.git -b master

git切换到另外一个branch (本例是develop分支):
git checkout develop

git删除一个branch(本例是myfeature):
git branch -d myfeature

Git删除一个远程branch:
git push origin :branchName

Git push 新的branch到远程:
git push -u origin mynewfeature

打印history中最后的cat命令
!cat:p

运行history中的最后的cat命令:
!cat

找出在/home/user中的所有空子目录:
find /home/user -maxdepth 1 -type d -empty

得到test.txt中50到60行的文本:
< test.txt sed -n '50,60p'

以sudo权限重新运行上一个执行的命令 (如果是: mkdir /root/test, 下面会运行: sudo mkdir /root/test)（译注：当你执行一个命令忘记sudo时，可以这样重新执行，而不必再把完整命令敲一遍）:
sudo !!

创建临时RAM文件系统 - ramdisk (请先创建 /tmpram 目录):
mount -t tmpfs tmpfs /tmpram -o size=512m

Grep完整的单词（译注：而不是其它单词的一部分）:
grep -w "name" test.txt

提升权限后在一个文件后追加文本:
echo "some text" | sudo tee -a /path/file

列出所有支持的kill信号:
kill -l

生成随机密码 (本例中16个字符长):
openssl rand -base64 16

在bash历史中不记录最后的会话:
kill -9 $$

扫描网络来找出开放的端口:
nmap -p 8081 172.20.0.0/16

设置git email:
git config --global user.email "me@example.com"

如果你有未提交的commit，与master同步:
git pull --rebase origin master

将文件名中含有txt的所有文件移动到/home/user:
find -iname "*txt*" -exec mv -v {} /home/user \;

按行将两个文件中的对应行合并显示:
paste test.txt test1.txt

shell中的进度条:
pv data.log

用netcat发送数据给服务器:
echo "hosts.sampleHost 10 `date +%s`" | nc 192.168.200.2 3000

转换tab为空格:
expand test.txt > test1.txt

跳过bash历史:
<<空格>>cmd

回到之前的工作目录:
cd -

切割大的tar.gz文件为几个文件 (每个100MB)，并还原:
split –b 100m /path/to/large/archive /path/to/output/files cat files* > archive

用curl获取HTTP状态值:
curl -sL -w "%{http_code}\\n" www.example.com -o /dev/null

当 Ctrl + c 没用时:
Ctrl + \

获取文件所有者:
stat -c %U file.txt

列出块设备:
lsblk -f

找出文件中带有末尾空格的文件:
find . -type f -exec egrep -l " +$" "{}" \;

找出用tab缩进的文件:
find . -type f -exec egrep -l $'\t' "{}" \;

用"="打印水平行
printf '%100s\n' | tr ' ' =
