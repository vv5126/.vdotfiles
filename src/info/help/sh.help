[ 目录 ]
1. 字符串替换 增减改删
2. 数学
3.
10. 信号处理
11. 脚本调试
12. bash中常用的命令
13. 部分总结
14. 技巧类


#========================================================================================#
1. 字符串替换 增减改删
#========================================================================================#
替换运算符
${var:-word}   如果var存在且非null，返回它的值；否则返回word
${var:=word}   如果var存在且非null，返回它的值；否则将word赋值给var，并返回var的值
${var:?word}   如果var存在且非null，返回它的值；否则显示var:word
${var:+word}   如果var存在且非null，返回word；否则返回null
注：冒号可省略

str='http://www.你的域名.com/cut-string.html'
1、从左边第几个字符开始以及字符的个数，用法为:start:len,例如：
echo ${var:0:5}
其中的 0 表示左边第一个字符开始，5 表示字符的总个数。结果是：http:
2、从左边第几个字符开始一直到结束，用法为:start,例如：
echo ${var:7}
其中的 7 表示左边第8个字符开始，结果是：www.你的域名.com/cut-string.html
3、从右边第几个字符开始以及字符的个数，用法:0-start:len,例如：
echo ${str:0-15:10}
其中的 0-6 表示右边算起第6个字符开始，10 表示字符的个数。结果是：cut-string
3、从右边第几个字符开始一直到结束，用法:0-start,例如：
echo ${str:0-4}
其中的 0-6 表示右边算起第6个字符开始，10 表示字符的个数。结果是：html
注：（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）

模式匹配运算符 (如 str='http://www.你的域名.com/cut-string.html')
${var#pattern}    匹配前缀（最小匹配），并返回余下内容echo ${str#*//}
cut-string.html
${var##pattern}    匹配前缀（最大匹配），并返回余下内容 echo ${str##*/}
www.你的域名.com/cut-string.html
${var%pattern}    匹配结尾（最小匹配），并返回余下内容   echo ${str%/*}
http://www.你的域名.com
${var%%pattern}    匹配结尾（最大匹配），并返回余下内容   echo ${str%%/*}
http://www.你的域名.com
注：pattern为正则表达式匹配

${file/dir/path}：将第一个 dir 提换为 path：/path1/dir2/dir3/my.file.txt
${file//dir/path}：将全部 dir 提换为 path：/path1/path2/path3/my.file.txt
${file-my.file.txt}: 若$file没有设定，则使用my.file.txt作返回值。(空值及非空值时不作处理)
${file:-my.file.txt}:若$file没有设定或为空值，则使用my.file.txt作返回值。(非空值时不作处理)
${file+my.file.txt}: 若$file设为空值或非空值，均使用my.file.txt作返回值。(没设定时不作处理)
${file:+my.file.txt}:若$file为非空值，则使用my.file.txt作返回值。(没设定及空值时不作处理)
${file=my.file.txt}: 若$file没设定，则使用my.file.txt作返回值，同时将$file 赋值为 my.file.txt。(空值及非空值时不作处理)
${file:=my.file.txt}:若$file没设定或为空值，则使用my.file.txt作返回值，同时将 $file 赋值为 my.file.txt。(非空值时不作处理)
${file?my.file.txt}: 若$file没设定，则将my.file.txt输出至 STDERR。(空值及非空值时不作处理)
${file:?my.file.txt}:若$file没设定或为空值，则将my.file.txt输出至STDERR。(非空值时不作处理)
注意: 
":+"的情况是不包含空值的.
":-", ":="等只要有号就是包含空值(null).
5. 变量的长度
${#file}
6. 数组运算
A=(a b c def)
${A[@]} 或 ${A[*]} 可得到 a b c def (全部组数)
${A[0]} 可得到 a (第一个组数)，${A[1]} 则为第二个组数...
${#A[@]} 或 ${#A[*]} 可得到 4 (全部组数数量)
${#A[0]} 可得到 1 (即第一个组数(a)的长度)，${#A[3]} 可得到 3 (第四个组数(def)的长度)

${#string}
{#string}
1，取得字符串长度
string=abc12342341          //等号二边不要有空格
echo ${#string}             //结果11
expr length $string         //结果11
expr "$string" : ".*"       //结果11 分号二边要有空格,这里的:根match的用法差不多2，字符串所在位置
expr index $string '123'    //结果4 字符串对应的下标是从0开始的这个方法让我想起来了js的indexOf，各种语言对字符串的操作方法大方向都差不多，如果有语言基础的话，学习shell会很快的。
3，从字符串开头到子串的最大长度
expr match $string 'abc.*3' //结果9个人觉得这个函数的用处不大，为什么要从开头开始呢。
4，字符串截取
echo ${string:4}      //2342341  从第4位开始截取后面所有字符串
echo ${string:3:3}    //123      从第3位开始截取后面3位
echo ${string:3:6}    //123423   从第3位开始截取后面6位
echo ${string: -4}    //2341  ：右边有空格   截取后4位
echo ${string:(-4)}   //2341  同上
expr substr $string 3 3   //123  从第3位开始截取后面3位上面的方法让我想起了，php的substr函数，后面截取的规则是一样的。
5，匹配显示内容
//例3中也有match和这里的match不同，上面显示的是匹配字符的长度，而下面的是匹配的内容
expr match $string '\([a-c]*[0-9]*\)'  //abc12342341
expr $string : '\([a-c]*[0-9]\)'       //abc1
expr $string : '.*\([0-9][0-9][0-9]\)' //341 显示括号中匹配的内容这里括号的用法，是不是根其他的括号用法有相似之处呢，
6，截取不匹配的内容
echo ${string#a*3}     //42341  从$string左边开始，去掉最短匹配子串
echo ${string#c*3}     //abc12342341  这样什么也没有匹配到
echo ${string#*c1*3}   //42341  从$string左边开始，去掉最短匹配子串
echo ${string##a*3}    //41     从$string左边开始，去掉最长匹配子串
echo ${string%3*1}     //abc12342  从$string右边开始，去掉最短匹配子串
echo ${string%%3*1}    //abc12     从$string右边开始，去掉最长匹配子串这里要注意，必须从字符串的第一个字符开始，或者从最后一个开始，
7，匹配并且替换
echo ${string/23/bb}   //abc1bb42341  替换一次
echo ${string//23/bb}  //abc1bb4bb41  双斜杠替换所有匹配
echo ${string/#abc/bb} //bb12342341   #以什么开头来匹配，根php中的^有点像
echo ${string/%41/bb}  //abc123423bb  %以什么结尾来匹配，根php中的$有点像

#========================================================================================#

#========================================================================================#
2. 数学
#========================================================================================#
算术运算符
算术运算符可以放置在$((...))里面，也就是内嵌算术，也称为算术展开。譬如 echo $((2>1)) 打印结果为1。（1表示真，0表示假）
shell 中数学计算总结
shell中的赋值和操作默认都是字符串处理，在此记下shell中进行数学运算的几个特殊方法，以后用到的时候可以来看，呵呵
2)使用(())
var=1
((var+=1))
echo $var
输出结果为2

3)使用$[]
var=1
var=$[$var+1]
echo $var
输出结果位2
注意：
a)$[]将中括号内的表达式作为数学运算先计算结果再输出
b)对$[]中的变量进行访问时前面需要加$
c)$[]支持的运算符与let相同，但也只支持整数运算

4)使用expr
var=1
var=`expr $var + 1`
echo $var
输出结果为2
注意：
a)expr后的表达式个符号间需用空格隔开
b)expr支持的操作符有： |、&、<、<=、=、!=、>=、>、+、-、*、/、%
c)expr支持的操作符中所在使用时需用\进行转义的有：|、&、<、<=、>=、>、*
e)expr同样只支持整数运算

5)使用bc(可以进行浮点数计算)
var=1
var=`echo "$var+1"|bc`
echo $var
输出结果为2
介绍：
bc是linux下的一个简单计算器，支持浮点数计算，在命令行下输入bc即进入计算器程序，而我们想在程序中直接进行浮点数计算时，利用一个简单的管道即可解决问题。
注意：
1)经我测试bc支持除位操作运算符之外的所有运算符。
2)bc中要使用scale进行精度设置
3)浮点数计算实例
var=3.14
var=`echo "scale=2;$var*3"|bc`
echo $var
输出结果为9.42

6)使用awk(可已进行浮点数计算)
var=1
var=`echo "$var 1"|awk '{printf("%g",$1*$2)}'`
echo $var
输出结果为2
介绍：
awk是一种文本处理工具，同时也是一种程序设计语言，作为一种程序设计语言，awk支持多种运算，而我们可以利用awk来进行浮点数计算，和上面bc一样，通过一个简单的管道，我们便可在程序中直接调用awk进行浮点数计算。
注意：
1)awk支持除微操作运算符之外的所有运算符
2)awk内置有log、sqr、cos、sin等等函数
3)浮点数计算实例
var=3.14
var=`echo "$var 2"|awk '{printf("%g",sin($1/$2))}'`
echo $var
输出结果为1
#========================================================================================#
${#parameter} 获得字符串的长度。


特殊变量
$HOME    表示当前用户根目录
$IFS    表示内部的字段分隔符
$LANG    当前locale默认名称
$PATH    环境变量
$PPID    父进程编号
$PWD    当前工作目录
$OLDPWD   ：记录旧的工作目录。
$OSTYPE  :记录操作系统类型。
$PS1  ：提示符变量，用于设置提示符格式，用于设置一级shell提示符环境变量。
$PS2  ：用于设置二级shell提示符环境变量。
$REPLY  ：REPLY变量与read和select有关。
$SECONDS：记录脚本从开始到结束耗费的时间。
$SHELL ：显示当前所用的shell
$SHELLOPTS  ：记录了处于“开”状态的shell选项列表，它只是一个只读变量。
$SHLVL   ：记录了bash嵌套的层次，一般来说，我们启动第一个Shell时。  $SHLVL=1。如果在这个Shell中执行脚本，脚本中的$SHLVL=2 。
$TMOUT  ：用来设置脚本过期的时间，比如TMOUT=3，表示该脚本3秒后过期。
$UID : 已登用户的ID
$USER ：显示当前用户名字
shell中创建的变量局部于创建它的shell，除非使用export命令特别指出是全局的。
LOGNAME 包含用户的注册名字
SHLVL 该变量包含当前工作的shell level
SHELL 环境变量存储了用户缺省的shell
Linux 中Shell环境变量总结
Shell环境变量在shell编程方面起到很重要的作用。分析下Shell中几个比较重要的环境变量很重要。所以下面分析一下。
$BASH ：记录当前bash shell的路径。
$BASH_SUBSHELL  ：记录当前子shell的层次。BASH_SUBSHELL是从0开始计数的整数。
$BASH_VERSINFO  ：是一个数组包含六个元素，这六个元素显示bash的版本信息。
$BASH_VERSION  ：显示shell版本的信息。
$DIRSTACK  ：记录了栈顶的目录值，初值为空。
$GLOBLGNORE ：是由冒号分割的模式列表，表示通配时忽略的文件名集合。
$GROUPS   ：记录当前用户所属的组。
$HOME ：记录当前用户的家目录，由/etc/passwd的倒数第二个域决定。
$HOSTNAME  ：记录主机名。
HOSTTYPE和MACHTYPE ：都是记录系统的硬件架构。
IFS 用于设置指定shell域分隔符，默认情况下为空格。
[root@localhost awK]# export IFS=:

$# 表示除$0之外的参数的个数。

$* 当前命令行所有参数。置于双引号中，表示将命令行所有参数当初一个单独参数
$* 以一个单字符串显示所有向脚本传递的参数，,以("$1 $2...")，除$0之外的参数的列表，但是这个列表是一个整体

$-（连字号）    在引用数给予Shell的选项
$- 显示shell使用的当前选项。

$! 后台运行的最后一个进程的ID号

$@ 当前命令行所有参数。置于双引号中，表示个别参数
$@ 除$0之外的参数的列表，这个列表时分开的
$@与$*相同，但是使用时加引号，并在引号中返回每个参数。("$1""$2"...)

$0 表示当前程序名称
$0:脚本名字。此变量包含地址，可以使用basename $0获得脚本名称。
$1:第一个参数
$2,$3,$4,$5,...一次类推。

$$ 是脚本运行的当前进程ID号

!$ 上一条指令的参数

单引号和双引号都屏蔽*的通配符作用。
${SAT}day，变量要与字符串连在一起时，应该用${}

!! 重复执行最后一条命令

$？命令执行的状态返回值
$?的参考值
0    成功退出
>0    退出失败
1-125    命令退出失败，失败返回的相关值由程序定义（譬如，程序内退出只执行 exit 2，则返回为2）
126    命令找到了，但无法执行
127    命令找不到
>128    命令因受到信号而kill

export 变量名：对下一层能包含使用；对上一层没作用。
export 变量名可把变量提升为全局环境变量，可供其他shell程序使用
unset 撤销变量
readonly 设置变量为只读，不能unset

Ctrl + a 切换到命令行开始
Ctrl + e 切换到命令行末尾
Ctrl + l 清除屏幕内容，效果等同于clear
Ctrl + u 剪切光标之前的内容
Ctrl + k 剪切清除光标之后的内容
Ctrl + y 粘贴刚才所删除的字符
Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了）
Ctrl + c 终止命令
Ctrl + d 退出shell，logout
Ctrl + z 转入后台运行 不过当前用户退出后就会终止，所以可以用nohup命令&

history 显示你所有执行过的编号+历史命令。这个可以配合!编辑来执行某某命令
Ctrl+p 显示上一条命令
Ctrl+n 显示下一条命令

提取最后一个参数
args=$#
lastargs=${!args}
echo $lastargs
echo ${!#}
echo $(eval echo "\$$#")
{ xxx } 左右要加空格！

=   等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
!=  不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
<   小于 应用于：整型比较 在[] 中，不能使用 表示字符串
>   大于 应用于：整型比较 在[] 中，不能使用 表示字符串
-eq 等于 应用于：整型比较
-ne 不等于 应用于：整型比较
-lt 小于 应用于：整型比较
-gt 大于 应用于：整型比较
-le 小于或等于 应用于：整型比较
-ge 大于或等于 应用于：整型比较
-a  双方都成立（and） 逻辑表达式 –a 逻辑表达式
-o  单方成立（or） 逻辑表达式 –o 逻辑表达式
-z  空字符串
-n  非空字符串

文件操作逻辑运算符：
-u               文件的UID标志被设置
-G               文件的组ID和当前用户相同
file1 -nt file2  文件file1比file2更新
file1 -ot file2  文件file1比file2更老
-r file　　　　　文件可读为真
-w file　　　　　文件可写为真
-x file　　　　　文件可执行为真
-f file　　　　　文件为正规文件为真
-d file　　　　　文件为目录为真
-c file　　　　　文件为字符特殊文件为真
-b file　　　　　文件为块特殊文件为真
-s file　　　　　文件大小非0时为真
-t file　　　　　当文件描述符(默认为1)指定的设备为终端时为真
-e file          当file存在时,返回True
-o file          当file文件的所有者是当前用户时,返回True
-z file          当file长度为0时,返回True

[ -n "$var"  ] ：判断$var变量是否有值
[ "$a" = "$b"  ] ：判断$a和$b是否相等

管道方法
str="$(cat <&0)"
echo -e "$str"

Shell脚本中判断变量为数字的3种方法
这篇文章主要介绍了Shell脚本中判断变量为数字的3种方法,本文分别介绍了expr、sed两种方法,并给出了一个判断脚本,需要的朋友可以参考下

方法1：通过expr 计算变量与一个整数值相加，如果能正常执行则为整数，否则执行出错,$?将是非0的值
expr $args + 0 &>/dev/null


方法2：打印变量通过sed替换的方式，将变量中的数字替换为空，如果执行替换后变量为空，则为整数
echo $args | sed 's/[0-9]//g'


如果判断负数则再用sed过滤负号
echo $args | sed 's/[0-9]//g' | sed 's/-//g'


#========================================================================================#
10. 信号处理
#========================================================================================#
trap命令用于在Shell程序中捕捉信号，之后可以有3种反应方式：
（1）执行一段程序来处理这一信号。
（2）接受信号的默认操作。
（3）忽视这一信号。
trap对上面3种方式提供了3种基本形式：
第一种形式的trap命令在Shell接收到与signal list清单中数值相同的信号时，将执行双引号中的命令串。
trap 'commands' signal-list
trap "commands" signal-list
为了恢复信号的默认操作，使用第二种形式的trap命令：
trap signal-list
第三种形式的trap命令允许忽略信号：
trap " " signal-list
注意：
（1）对信号11（段违例）不能捕捉，因为Shell本身需要捕捉该信号去进行内存的转储。
（2）在trap中可以定义对信号0的处理（实际上没有这个信号），Shell程序在其终止（如执行exit语句）时发出该信号。
（3）在捕捉到signal-list中指定的信号并执行完相应的命令之后，如果这些命令没有将Shell程序终止的话，Shell程序将继续执行收到信号时所执行的命令后面的命令，这样将很容易导致Shell程序无法终止。
另外，在trap语句中，单引号和双引号是不同的。当Shell程序第一次碰到trap语句时，将把commands中的命令扫描一遍。此时若 commands是用单引号括起来的话，那么Shell不会对commands中的变量和命令进行替换，否则commands中的变量和命令将用当时具体的值来替换。
#========================================================================================#

#========================================================================================#
11. 脚本调试
#========================================================================================#
 在编程过程中难免会出错，有的时候，调试程序比编写程序花费的时间还要多，Shell程序同样如此。　　Shell程序的调试主要是利用bash命令解释程序的选择项。
 调用bash的形式是：　　
 bash -选择项Shell程序文件名几个常用的选择项是：
 　　-e如果一个命令失败就立即退出。
 　　-n读入命令但是不执行它们。
 　　-u置换时把未设置的变量看做出错。
 　　-v当读入Shell输入行时把它们显示出来。
 　　-x执行命令时把命令和它们的参数显示出来。
#========================================================================================#

#========================================================================================#
12. bash中常用的命令
#========================================================================================#
Alias   | 设置命令别名
unalias | 删除命令行别名
Bg      | 将一个被挂起的进程在后台执行
cd      | 改变用户的当前目录
exit    | 终止一个shell
export  | 使作为这个命令的参数的变量及其当前值,在当前运行的shell的子进程中可见
fc      | 编辑当前的命令行历史列表
fg      | 让一个被挂起的进程在前台执行
help    | 显示bash内部命令的帮助信息
history | 显示最近输入的一定数量的命令行
kill    | 终止一个进程
pwd     | 显示用户当前工作目录
#========================================================================================#

#========================================================================================#
13. 部分总结
#========================================================================================#
$UID 当前权限，为0时为root权限。
[]或语句(利用返回值$?) && || 相当于if语句，最好加{}。
exit 0
清空 cat /dev/null > xxx
awk sed expect 都是语言
脚本执行方法  sh xxx，或者放到bin下，全路径或者直接当前路径./为重新fork 子shell。source xxx，. xxx是非fork。
bashrc profile 等等中都是环境变量，都属于脚本。
[]两端要有空格。
环境变量就是全局变量。（相对与当前父shell和子shell）
启用shell脚本一般是属于子shell其中的变量为局部，退出即释放。
所有profile bashrc 等等其实都一样，存的是全局变量或者做些全局的事，启动账户时会建立这些全局工作（登录交互）。非登录交互只会走特定文件，其实可以互相嵌入。需要使用export导出！
su - xxx 切换用户
set 显示所有本地变量，unset 取消环境变量
命令变量 `xxx` 在调用时会执行可执行文件，可带参数，还可以使用$(xxx)。
变量使用标准 "${xxx}"。
函数体内一般变量加local。
多模仿系统脚本。
传参，$*当做一个变量传递，$@保留原有变量状态。
脚本里使用 set -- xxx xxx xxx 相当于传入参数。
shift 参数左移，相当于隐藏了最前面的参数。
${//}替换第一个，${/%/}结尾匹配，${/#/}开头匹配。
echo -n 不换行。
man bash 常看手册。
数学计算：((xxx)) let expr bc $[xxx]，bc可以进行浮点运算。let expr $[xxx] 少用。
less 分屏查看。
判断整数：expr xxx + 0 &>/dev/null 看$？。
bc 一般用管道，scale=2 保留小数个数。obase=2 进制转换，这里是2进制。
read [参数] [变量] -p 提示 -t 超时时间。后跟 $a $b...... ,可以设置传几个参数。
判断:[] [[]]，基本使用这两种，[[]]可以使用&& || <> 等符号。
一般数学符号需要在[[]]，(())中使用。单的不支持，只能用-eq什么的，= ！ 倒是可以。
巧用cat进行多行数据的输出，cat << END  xxxxxxxxxxxx END。
分号相当于换行。
crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。需要安装crond服务。
read 参数 -t 超时时间 -p 提示语 read -t 10 -p "hehe:" a b 可传入多参数。
if [xxx] 可以用((xxx))代替，比较符号要改。
wc -l 转换为数字
namp 远程端口状态查看
head -1 第一行，-n就是前几行，tail -n 可以取后几行，这两个可以协同工作取区间行。
cut -d "xxx" -fxxx 以什么隔开字符并取第几部分。
talnet xxx 端口 
case语句 每个）可以使用|来加入多个判断在一个条件里。
echo xxx && echo -en \\033[1;31m 为xxx加颜色的另一个方法。
fg +n n为后台程序序号将后台程序转到当前前台操作。jobs 看所有后台。
C+z 暂停当前前台程序，bg扔到后台执行。
tail -f xxx 跟踪文件变化。有变化就打印。
一些简写 {1..9} {a..g}
有规律的序列可以用seq生成。
使用echo 传变量到管道，另一边怎么接？？ 使用 --stdin 代替就行了：echo "hehe" | mkdir --stdin。
随机数 $RANDOM|md5sum，或者可以更复杂。
break 跳出所有包括嵌套的循环，break n跳出n个循环。
continue n 表示退到第n个层在进行循环。
函数库使用source进行预加载就能用了。
添加到文件：cat>xxx<<EOF xxx\n xxx\n EOF。
使用etc/init.d/functions的函数库，echo可以用action "xxx" /bin/ture 代替，会好看些。
取整个数组：${数组名[*]}，数组数量：${#数组名[*]}。
数组常用方法：xxx=($(ls))
驼峰命名变量
调试： sh -v 打印执行的句子有错再报 -n 不执行只检查 -x 一边打印一边解析一边报错
在代码中加入set -x 可以打印出调试信息，set +x 关闭调试。执行时不不用加-x了这种情况下。
trap "" 信号名 ，可以将信号设定为某些功能，或者屏蔽原有功能。trap ":" 信号名 ，恢复原功能。
trap -l 列出所有信号，stty -a 显示信号的快捷键。
dos2unix 可以将dos下的脚本格式化为unix下的。
gg=G 排版
函数内局部变量加local。
以变量形式进行传参，要加双引号，防错。
大的循环最好使用awk代替。
export LANG=“zh_CN.GB18030"使用中文字符集。
Linux提供了自定义自动补全的命令：complete, 有一个-W参数，意思是把要补全的命令写到里面，整个命令的写法:complete -W "aaa bbb ccc" xxx.sh，加到bashrc中。
变量赋值一定一定不要乱加空格！！ CMD=`ls -a`
双引号内的特殊字符可以保有变量特性，但是单引号内的特殊字符则仅为一般字符。
反斜线用来屏蔽特殊字符的特殊含义
#========================================================================================#
杂乱
#========================================================================================#
C+w 从字符删除到空格
C+a 行首
C+- 减小字体
C++ 增加字体
C+j 回车
C+u 撤销
C+y 重做
C+l 清屏
C+d 删除当前字符
C+e 行尾
C+r 查找
C+t 交换前两字符
#========================================================================================#
由双引号括起来的字符，除$、倒引号`和反斜线\ 仍保留其特殊功能外，其余字符均作为普通字符对待。
仅当“\”后面的字符是下述字符之一时，“\”才是转义字符，这些字符是：“$”、“`”、“"”、“\”或换行符。
而对”号，若其前面没有加，则Shell会将它同前一个”号匹配。
$ TestString＝”$PATH\”$PATH”
.:/usr/bin:/ bin”$PATH

格式：echo '你的密码'|sudo -S 执行命令
ssh 远程用户名@远程主机IP地址 ‘远程命令或者脚本’ 
可能要执行    source ~/.profile 否则无法使用.bin中的东西。

在shell中使用管道，会fork一个子shell，传入其中的变量为局部变量。
在使用read file时可以使用cat file | while read line；do done 或者在done后< file，就不会重新fork子shell了。
需要用source或者.执行，这样会在当前shell环境中执行，如果直接执行，会开启一个子shell,你在子shell中进入了该目录，脚本执行完后会退出子shell回到父shell环境


#========================================================================================#
14. 技巧类
#========================================================================================#
用命令行往配置文件里插入多行文本
cat >> path/to/file/to/append-to.txt << "EOF"
export PATH=$HOME/jdk1.8.0_31/bin:$PATH
export JAVA_HOME=$HOME/jdk1.8.0_31/
EOF

#========================================================================================#
