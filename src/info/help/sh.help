替换运算符
${var:-word}     如果var存在且非null，返回它的值；否则返回word
${var:=word}   如果var存在且非null，返回它的值；否则将word赋值给var，并返回var的值 
${var:?word}    如果var存在且非null，返回它的值；否则显示var:word
${var:+word}     如果var存在且非null，返回word；否则返回null
注：冒号（:）可省略

${#parameter} 获得字符串的长度。

模式匹配运算符 (如 str='http://www.你的域名.com/cut-string.html')
${var#pattern}    匹配前缀（最小匹配），并返回余下内容echo ${str#*//} 
cut-string.html
${var##pattern}    匹配前缀（最大匹配），并返回余下内容 echo ${str##*/}
www.你的域名.com/cut-string.html
${var%pattern}    匹配结尾（最小匹配），并返回余下内容   echo ${str%/*}
http://www.你的域名.com
${var%%pattern}    匹配结尾（最大匹配），并返回余下内容   echo ${str%%/*}
http://www.你的域名.com
注：pattern为正则表达式匹配

算术运算符
算术运算符可以放置在$((...))里面，也就是内嵌算术，也称为算术展开。譬如 echo $((2>1)) 打印结果为1。（1表示真，0表示假）

特殊变量
$#    表示变量的个数，常用于循环
$@    当前命令行所有参数。置于双引号中，表示个别参数
$*    当前命令行所有参数。置于双引号中，表示将命令行所有参数当初一个单独参数
$-（连字号）    在引用数给予Shell的选项
$?    表示上一个命令退出的状态
$$    表示当前进程编号
$0    表示当前程序名称
$!    表示最近一个后台命令的进程编号
$HOME    表示当前用户根目录
$IFS    表示内部的字段分隔符
$LANG    当前locale默认名称
$PATH    环境变量
$PPID    父进程编号
$PWD    当前工作目录

$?的参考值
0    成功退出
>0    退出失败
1-125    命令退出失败，失败返回的相关值由程序定义（譬如，程序内退出只执行 exit 2，则返回为2）
126    命令找到了，但无法执行
127    命令找不到
>128    命令因受到信号而kill


str='http://www.你的域名.com/cut-string.html'
1、从左边第几个字符开始以及字符的个数，用法为:start:len,例如：
echo ${var:0:5}
其中的 0 表示左边第一个字符开始，5 表示字符的总个数。结果是：http:
2、从左边第几个字符开始一直到结束，用法为:start,例如：
echo ${var:7}
其中的 7 表示左边第8个字符开始，结果是：www.你的域名.com/cut-string.html
3、从右边第几个字符开始以及字符的个数，用法:0-start:len,例如：
echo ${str:0-15:10}
其中的 0-6 表示右边算起第6个字符开始，10 表示字符的个数。结果是：cut-string
3、从右边第几个字符开始一直到结束，用法:0-start,例如：
echo ${str:0-4}
其中的 0-6 表示右边算起第6个字符开始，10 表示字符的个数。结果是：html
注：（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）

export 变量名：对下一层能包含使用；对上一层没作用。
unset 取消设置变量
测试条件：test condition 等效[ condition ]

!$ 上一条指令的参数
Ctrl + a 切换到命令行开始
Ctrl + e 切换到命令行末尾
Ctrl + l 清除屏幕内容，效果等同于clear
Ctrl + u 剪切光标之前的内容
Ctrl + k 剪切清除光标之后的内容
Ctrl + y 粘贴刚才所删除的字符
Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了）
Ctrl + c 终止命令
Ctrl + d 退出shell，logout
Ctrl + z 转入后台运行 不过当前用户退出后就会终止，所以可以用nohup命令&
!! 重复执行最后一条命令
history 显示你所有执行过的编号+历史命令。这个可以配合!编辑来执行某某命令
↑(Ctrl+p) 显示上一条命令
↓(Ctrl+n) 显示下一条命令

提取最后一个参数

args=$#
lastargs=${!args}
echo $lastargs
echo ${!#}
echo $(eval echo "\$$#")
{ xxx } 左右要加空格！

=   等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
!=  不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
<   小于 应用于：整型比较 在[] 中，不能使用 表示字符串
>   大于 应用于：整型比较 在[] 中，不能使用 表示字符串
-eq 等于 应用于：整型比较
-ne 不等于 应用于：整型比较
-lt 小于 应用于：整型比较
-gt 大于 应用于：整型比较
-le 小于或等于 应用于：整型比较
-ge 大于或等于 应用于：整型比较
-a  双方都成立（and） 逻辑表达式 –a 逻辑表达式
-o  单方成立（or） 逻辑表达式 –o 逻辑表达式
-z  空字符串
-n  非空字符串

管道方法
str="$(cat <&0)"
echo -e "$str"
